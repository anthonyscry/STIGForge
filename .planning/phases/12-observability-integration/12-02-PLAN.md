---
phase: 12-observability-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Infrastructure/Telemetry/DebugBundleExporter.cs
  - src/STIGForge.Cli/Commands/ExportDebugBundleCommand.cs
autonomous: true
requirements:
  - OBSV-05
must_haves:
  truths:
    - "Debug export bundles can be created containing logs, traces, bundle artifacts, and system info"
    - "CLI command exists to trigger debug bundle creation on demand"
    - "Bundle manifest.json lists all included artifacts and export metadata"
  artifacts:
    - path: "src/STIGForge.Infrastructure/Telemetry/DebugBundleExporter.cs"
      provides: "ZIP archive creation with diagnostic artifacts"
      exports: ["DebugBundleExporter", "DebugBundleRequest", "DebugBundleResult"]
    - path: "src/STIGForge.Cli/Commands/ExportDebugBundleCommand.cs"
      provides: "CLI command for on-demand debug bundle creation"
      exports: ["ExportDebugBundleCommand"]
  key_links:
    - from: "DebugBundleExporter"
      to: "System.IO.Compression.ZipFile"
      via: "ZipArchive.CreateEntryFromFile"
      pattern: "ZipFile\\.Open.*CreateEntryFromFile"
    - from: "ExportDebugBundleCommand"
      to: "DebugBundleExporter"
      via: "DI constructor injection"
      pattern: "new DebugBundleExporter"
---

<objective>
Create a debug bundle exporter that aggregates all diagnostic artifacts into a portable ZIP file for offline support scenarios.

Purpose: Enable operators to create comprehensive diagnostic packages that can be shared with support teams for troubleshooting. The bundle includes application logs, trace files, bundle-specific logs, verification output, and system information.

Output: DebugBundleExporter service and CLI command for on-demand export.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-observability-integration/12-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Existing infrastructure
@src/STIGForge.Core/Abstractions/Services.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DebugBundleExporter service</name>
  <files>
    src/STIGForge.Infrastructure/Telemetry/DebugBundleExporter.cs
  </files>
  <action>
    Create DebugBundleExporter.cs in the Telemetry namespace implementing portable diagnostic bundle creation:

    The service must:
    1. Accept DebugBundleRequest with optional BundleRoot, IncludeDaysOfLogs (default 7), and ExportReason
    2. Create a timestamped ZIP file in logs/exports/ directory
    3. Include:
       - logs/ - Application logs from last N days (filtered by file modification time)
       - bundle/ - If BundleRoot provided: Apply/Logs, Verify/*.json, Apply/apply_run.json
       - traces/ - traces.json if exists
       - system-info.json - Machine name, OS, runtime, timestamp
       - manifest.json - Export metadata (timestamp, version, reason, what was included)

    Key implementation details:
    - Use IPathBuilder.GetLogsRoot() for the logs root path (inject via constructor)
    - Use System.IO.Compression.ZipFile for archive creation
    - Handle missing files/directories gracefully (skip rather than fail)
    - Return DebugBundleResult with OutputPath, FileCount, CreatedAt

    ```csharp
    namespace STIGForge.Infrastructure.Telemetry;

    public sealed class DebugBundleExporter
    {
        private readonly IPathBuilder _paths;

        public DebugBundleExporter(IPathBuilder paths)
        {
            _paths = paths ?? throw new ArgumentNullException(nameof(paths));
        }

        public DebugBundleResult ExportBundle(DebugBundleRequest request)
        {
            // Implementation follows RESEARCH.md Pattern 4
        }

        private void AddLogsToArchive(ZipArchive archive, string logsRoot, int days) { ... }
        private void AddBundleLogsToArchive(ZipArchive archive, string bundleRoot) { ... }
        private void AddTracesToArchive(ZipArchive archive, string logsRoot) { ... }
        private void AddSystemInfoToArchive(ZipArchive archive) { ... }
        private void AddManifestToArchive(ZipArchive archive, DebugBundleRequest request) { ... }
    }

    public sealed class DebugBundleRequest
    {
        public string? BundleRoot { get; set; }
        public int IncludeDaysOfLogs { get; set; } = 7;
        public string? ExportReason { get; set; }
    }

    public sealed class DebugBundleResult
    {
        public string OutputPath { get; set; } = string.Empty;
        public int FileCount { get; set; }
        public DateTimeOffset CreatedAt { get; set; }
    }
    ```

    Follow existing codebase patterns:
    - Sealed classes
    - Null checks with throw expressions
    - XML documentation
  </action>
  <verify>
    Build the project: `dotnet build src/STIGForge.Infrastructure/STIGForge.Infrastructure.csproj`
  </verify>
  <done>
    DebugBundleExporter.cs exists with ExportBundle method that creates valid ZIP archives.
    DebugBundleRequest and DebugBundleResult models defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CLI command for debug bundle export</name>
  <files>
    src/STIGForge.Cli/Commands/ExportDebugBundleCommand.cs
  </files>
  <action>
    Create ExportDebugBundleCommand.cs following the existing CLI command pattern in the codebase:

    The command should:
    1. Accept options:
       - `--bundle-root` (optional): Path to bundle directory for bundle-specific artifacts
       - `--days` (optional): Number of days of logs to include (default: 7)
       - `--reason` (optional): Export reason for manifest
    2. Resolve IPathBuilder and DebugBundleExporter from DI
    3. Call ExportBundle and print result to console
    4. Return exit code 0 on success, 1 on failure

    Look at existing CLI commands in src/STIGForge.Cli/Commands/ for the pattern:
    - Use System.CommandLine for argument parsing
    - Use ILogger for structured logging
    - Follow the existing command registration pattern

    Register the command in the CLI host configuration.
  </action>
  <verify>
    Build CLI project: `dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj`
    Test help output: `dotnet run --project src/STIGForge.Cli -- export-debug-bundle --help`
  </verify>
  <done>
    ExportDebugBundleCommand.cs exists and is registered in CLI.
    Running `stigforge export-debug-bundle --help` shows command usage.
  </done>
</task>

</tasks>

<verification>
1. Build all affected projects
2. Verify ZIP archive creation works (can test manually with CLI command)
3. Verify manifest.json includes expected metadata
4. Verify missing files are handled gracefully without exceptions
</verification>

<success_criteria>
- DebugBundleExporter creates valid ZIP archives with diagnostic artifacts
- CLI command `export-debug-bundle` is available and functional
- Bundle manifest includes export metadata and file listing
- No external NuGet packages required (uses built-in System.IO.Compression)
</success_criteria>

<output>
After completion, create `.planning/phases/12-observability-integration/12-02-SUMMARY.md`
</output>
