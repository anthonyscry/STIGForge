---
phase: 12-observability-integration
plan: 03
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - src/STIGForge.Build/BundleOrchestrator.cs
autonomous: true
requirements:
  - OBSV-02
must_haves:
  truths:
    - "Mission lifecycle emits correlated Activity spans for Build, Apply, Verify, and Evidence phases"
    - "Phase spans include bundle root, run ID, and outcome tags"
    - "Failed phases set ActivityStatusCode.Error with description"
    - "Serilog logs correlate with Activity trace IDs via CorrelationIdEnricher"
  artifacts:
    - path: "src/STIGForge.Build/BundleOrchestrator.cs"
      provides: "Mission lifecycle orchestration with tracing"
      contains: "MissionTracingService"
  key_links:
    - from: "BundleOrchestrator"
      to: "MissionTracingService"
      via: "Constructor injection and using pattern"
      pattern: "using var.*Activity.*StartMissionSpan|StartPhaseSpan"
    - from: "Phase spans"
      to: "CorrelationIdEnricher"
      via: "Activity.Current"
      pattern: "Activity\\.Current\\.TraceId"
---

<objective>
Wire the MissionTracingService into BundleOrchestrator to emit correlated Activity spans for the entire mission lifecycle.

Purpose: Enable end-to-end observability of mission execution with trace spans that correlate Build -> Apply -> Verify -> Evidence phases. Each phase becomes a child span under the root mission span, allowing offline analysis of mission timing and outcomes.

Output: Modified BundleOrchestrator with Activity span wrapping for all lifecycle phases.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-observability-integration/12-RESEARCH.md

# Prior plan output
@.planning/phases/12-observability-integration/12-01-SUMMARY.md

# Code to modify
@src/STIGForge.Build/BundleOrchestrator.cs
@src/STIGForge.Infrastructure/Telemetry/MissionTracingService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject MissionTracingService into BundleOrchestrator</name>
  <files>
    src/STIGForge.Build/BundleOrchestrator.cs
  </files>
  <action>
    Modify BundleOrchestrator to use MissionTracingService:

    1. Add using statement: `using STIGForge.Infrastructure.Telemetry;`

    2. Add MissionTracingService field and constructor parameter:
    ```csharp
    private readonly MissionTracingService _tracing;

    public BundleOrchestrator(
        BundleBuilder builder,
        ApplyRunner apply,
        IVerificationWorkflowService verificationWorkflow,
        VerificationArtifactAggregationService artifactAggregation,
        MissionTracingService tracing,  // Add this
        IAuditTrailService? audit = null,
        IMissionRunRepository? missionRunRepository = null)
    {
        _builder = builder;
        _apply = apply;
        _verificationWorkflow = verificationWorkflow;
        _artifactAggregation = artifactAggregation;
        _tracing = tracing ?? throw new ArgumentNullException(nameof(tracing));
        _audit = audit;
        _missionRunRepository = missionRunRepository;
    }
    ```

    3. In OrchestrateAsync method, wrap the entire mission lifecycle:
    ```csharp
    public async Task OrchestrateAsync(OrchestrateRequest request, CancellationToken ct)
    {
        // ... existing validation ...

        // Start root mission span
        using var missionActivity = _tracing.StartMissionSpan(root, runId);

        try
        {
            // --- Apply phase ---
            using var applyActivity = _tracing.StartPhaseSpan(ActivitySourceNames.ApplyPhase, root);
            await AppendEventAsync(runId, ++seq, MissionPhase.Apply, "apply", MissionEventStatus.Started, null, ct);

            try
            {
                applyResult = await _apply.RunAsync(...);
                _tracing.SetStatusOk(applyActivity);
                _tracing.AddPhaseEvent(applyActivity, "apply_completed", $"Steps={applyResult.Steps.Count}");
            }
            catch (Exception ex)
            {
                _tracing.SetStatusError(applyActivity, ex.Message);
                applyActivity?.SetTag("error.type", ex.GetType().FullName);
                throw;
            }

            // --- Verify phase (Evaluate-STIG) ---
            if (!string.IsNullOrWhiteSpace(request.EvaluateStigRoot))
            {
                using var verifyActivity = _tracing.StartPhaseSpan("verify_evaluate_stig", root);
                // ... existing logic with try/catch setting status ...
            }

            // --- Verify phase (SCAP) ---
            if (!string.IsNullOrWhiteSpace(request.ScapCommandPath))
            {
                using var scapActivity = _tracing.StartPhaseSpan("verify_scap", root);
                // ... existing logic with try/catch setting status ...
            }

            // --- Evidence phase ---
            if (coverageInputs.Count > 0)
            {
                using var evidenceActivity = _tracing.StartPhaseSpan(ActivitySourceNames.ProvePhase, root);
                // ... existing logic ...
            }

            _tracing.SetStatusOk(missionActivity);
        }
        catch (Exception ex)
        {
            _tracing.SetStatusError(missionActivity, ex.Message);
            missionActivity?.SetTag("error.type", ex.GetType().FullName);
            throw;
        }
    }
    ```

    Key patterns:
    - Use `using` pattern for all Activity spans (guarantees disposal/end of span)
    - Set Ok status on success, Error status on exception
    - Add error.type tag on failures for categorization
    - Each phase gets its own child span under the root mission span
  </action>
  <verify>
    Build the project: `dotnet build src/STIGForge.Build/STIGForge.Build.csproj`
    Verify no compilation errors.
  </verify>
  <done>
    BundleOrchestrator injects MissionTracingService and wraps all lifecycle phases with Activity spans.
    Spans set appropriate status codes and error tags.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register MissionTracingService in DI containers</name>
  <files>
    src/STIGForge.App/App.xaml.cs
    src/STIGForge.Cli/CliHostFactory.cs
  </files>
  <action>
    Register MissionTracingService as a singleton in both WPF and CLI host configurations:

    In App.xaml.cs (WPF host), add to service collection:
    ```csharp
    services.AddSingleton<MissionTracingService>();
    ```

    In CliHostFactory.cs (CLI host), add the same registration.

    This ensures MissionTracingService is available for injection into BundleOrchestrator.
  </action>
  <verify>
    Build both projects and verify DI registration compiles:
    - `dotnet build src/STIGForge.App/STIGForge.App.csproj`
    - `dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj`
  </verify>
  <done>
    MissionTracingService registered as singleton in both hosts.
    BundleOrchestrator receives MissionTracingService via DI.
  </done>
</task>

</tasks>

<verification>
1. Build all affected projects
2. Verify BundleOrchestrator compiles with MissionTracingService injection
3. Verify DI registrations in both hosts
4. Check that all phases (Apply, Verify-Evaluate-STIG, Verify-SCAP, Evidence) are wrapped with Activity spans
</verification>

<success_criteria>
- BundleOrchestrator emits root mission span and child phase spans
- All spans use `using` pattern for guaranteed disposal
- Spans include relevant tags (bundle.root, phase.name, error.type)
- Exception paths set ActivityStatusCode.Error
- MissionTracingService registered in DI for both CLI and WPF hosts
</success_criteria>

<output>
After completion, create `.planning/phases/12-observability-integration/12-03-SUMMARY.md`
</output>
