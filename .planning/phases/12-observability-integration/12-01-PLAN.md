---
phase: 12-observability-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Infrastructure/Telemetry/ActivitySourceNames.cs
  - src/STIGForge.Infrastructure/Telemetry/MissionTracingService.cs
  - src/STIGForge.Infrastructure/Telemetry/TraceContext.cs
  - src/STIGForge.Infrastructure/Telemetry/TraceFileListener.cs
  - src/STIGForge.Infrastructure/Logging/LoggingConfiguration.cs
autonomous: true
requirements:
  - OBSV-02
must_haves:
  truths:
    - "MissionTracingService can start Activity spans for mission lifecycle phases"
    - "TraceContext captures current Activity trace/span IDs for propagation"
    - "ActivityListener writes trace spans to local JSON file for offline analysis"
    - "CorrelationIdEnricher continues to work with Activity.Current"
  artifacts:
    - path: "src/STIGForge.Infrastructure/Telemetry/MissionTracingService.cs"
      provides: "ActivitySource-based mission span creation"
      exports: ["MissionTracingService"]
    - path: "src/STIGForge.Infrastructure/Telemetry/TraceContext.cs"
      provides: "Serializable trace context for process boundary propagation"
      exports: ["TraceContext"]
    - path: "src/STIGForge.Infrastructure/Telemetry/ActivitySourceNames.cs"
      provides: "Centralized ActivitySource and span naming constants"
      exports: ["ActivitySourceNames"]
    - path: "src/STIGForge.Infrastructure/Telemetry/TraceFileListener.cs"
      provides: "ActivityListener that writes spans to traces.json"
      exports: ["TraceFileListener"]
  key_links:
    - from: "MissionTracingService"
      to: "System.Diagnostics.ActivitySource"
      via: "StartActivity with using pattern"
      pattern: "ActivitySource\\.StartActivity"
    - from: "TraceFileListener"
      to: "traces.json"
      via: "ActivityStopped callback"
      pattern: "ActivityStopped.*File\\.AppendAllText"
---

<objective>
Create the mission tracing infrastructure using .NET 8 built-in Activity/ActivitySource for W3C-compatible distributed tracing.

Purpose: Enable end-to-end mission observability with trace spans that correlate across the Build -> Apply -> Verify -> Prove lifecycle. This infrastructure will be consumed by BundleOrchestrator and ApplyRunner in subsequent plans.

Output: MissionTracingService, TraceContext, ActivitySourceNames, and TraceFileListener classes in new Telemetry namespace.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-observability-integration/12-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md

# Existing infrastructure to integrate with
@src/STIGForge.Infrastructure/Logging/CorrelationIdEnricher.cs
@src/STIGForge.Infrastructure/Logging/LoggingConfiguration.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ActivitySourceNames and TraceContext models</name>
  <files>
    src/STIGForge.Infrastructure/Telemetry/ActivitySourceNames.cs
    src/STIGForge.Infrastructure/Telemetry/TraceContext.cs
  </files>
  <action>
    Create the Telemetry directory under src/STIGForge.Infrastructure/ and implement:

    1. ActivitySourceNames.cs - Static class with constants:
       - `public const string Missions = "STIGForge.Missions";`
       - Span name constants: BuildPhase, ApplyPhase, VerifyPhase, ProvePhase

    2. TraceContext.cs - Sealed record/class capturing W3C trace context:
       - Properties: TraceId (string), SpanId (string), TraceFlags (string)
       - Static method `GetCurrentContext()` that reads Activity.Current and returns TraceContext or null
       - Used for serializing trace context to environment variables for PowerShell propagation

    Follow existing codebase conventions:
    - File-scoped namespaces: `namespace STIGForge.Infrastructure.Telemetry;`
    - Sealed classes, nullable enabled
    - XML documentation for public members
  </action>
  <verify>
    Build the project: `dotnet build src/STIGForge.Infrastructure/STIGForge.Infrastructure.csproj`
    Verify no compilation errors and the Telemetry namespace is accessible.
  </verify>
  <done>
    ActivitySourceNames.cs and TraceContext.cs exist in src/STIGForge.Infrastructure/Telemetry/
    TraceContext.GetCurrentContext() returns populated object when Activity.Current exists.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MissionTracingService</name>
  <files>
    src/STIGForge.Infrastructure/Telemetry/MissionTracingService.cs
  </files>
  <action>
    Create MissionTracingService.cs implementing ActivitySource-based span creation:

    ```csharp
    namespace STIGForge.Infrastructure.Telemetry;

    public sealed class MissionTracingService
    {
        private static readonly ActivitySource ActivitySource = new(ActivitySourceNames.Missions);

        public Activity? StartMissionSpan(string bundleRoot, string runId)
        {
            var activity = ActivitySource.StartActivity("mission", ActivityKind.Server);
            if (activity != null)
            {
                activity.SetTag("bundle.root", bundleRoot);
                activity.SetTag("mission.run_id", runId);
                activity.SetTag("mission.started_at", DateTimeOffset.UtcNow.ToString("o"));
            }
            return activity;
        }

        public Activity? StartPhaseSpan(string phaseName, string bundleRoot)
        {
            var activity = ActivitySource.StartActivity(phaseName, ActivityKind.Internal);
            if (activity != null)
            {
                activity.SetTag("phase.name", phaseName);
                activity.SetTag("bundle.root", bundleRoot);
            }
            return activity;
        }

        public void AddPhaseEvent(Activity? activity, string eventName, string? message = null)
        {
            activity?.AddEvent(new ActivityEvent(eventName, tags: new ActivityTagsCollection
            {
                ["message"] = message ?? string.Empty
            }));
        }

        public void SetStatusOk(Activity? activity)
        {
            activity?.SetStatus(ActivityStatusCode.Ok);
        }

        public void SetStatusError(Activity? activity, string description)
        {
            activity?.SetStatus(ActivityStatusCode.Error, description);
        }
    }
    ```

    Key patterns:
    - Use `using` pattern for Activity disposal (consumers must dispose)
    - ActivityKind.Server for root mission span, ActivityKind.Internal for phases
    - Set tags following OpenTelemetry semantic conventions (dot notation)
  </action>
  <verify>
    Build the project and verify MissionTracingService can be instantiated and StartMissionSpan returns a non-null Activity.
  </verify>
  <done>
    MissionTracingService.cs exists with StartMissionSpan, StartPhaseSpan, AddPhaseEvent, SetStatusOk, SetStatusError methods.
    ActivitySource is created with "STIGForge.Missions" name.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TraceFileListener for local trace output</name>
  <files>
    src/STIGForge.Infrastructure/Telemetry/TraceFileListener.cs
    src/STIGForge.Infrastructure/Logging/LoggingConfiguration.cs
  </files>
  <action>
    Create TraceFileListener.cs implementing ActivityListener that writes spans to JSON file:

    ```csharp
    namespace STIGForge.Infrastructure.Telemetry;

    public sealed class TraceFileListener : IDisposable
    {
        private readonly string _tracesPath;
        private readonly object _lock = new();
        private readonly ActivityListener _listener;
        private bool _disposed;

        public TraceFileListener(string logsRoot)
        {
            _tracesPath = Path.Combine(logsRoot, "traces.json");
            Directory.CreateDirectory(Path.GetDirectoryName(_tracesPath)!);

            _listener = new ActivityListener
            {
                ShouldListenTo = source => source.Name.StartsWith("STIGForge"),
                SampleUsingParentId = (ref ActivityCreationOptions<string> _) => ActivitySamplingResult.AllData,
                Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllData,
                ActivityStopped = WriteSpanToFile
            };

            ActivitySource.AddActivityListener(_listener);
        }

        private void WriteSpanToFile(Activity activity)
        {
            var span = new
            {
                traceId = activity.TraceId.ToString(),
                spanId = activity.SpanId.ToString(),
                parentSpanId = activity.ParentSpanId.ToString(),
                operationName = activity.OperationName,
                kind = activity.Kind.ToString(),
                startTime = activity.StartTimeUtc.ToString("o"),
                durationMs = activity.Duration.TotalMilliseconds,
                status = activity.Status.ToString(),
                statusDescription = activity.StatusDescription,
                tags = activity.Tags?.ToDictionary(t => t.Key, t => t.Value),
                events = activity.Events.Select(e => new
                {
                    name = e.Name,
                    timestamp = e.Timestamp.ToString("o"),
                    tags = e.Tags?.ToDictionary(t => t.Key, t => t.Value)
                }).ToList()
            };

            var line = JsonSerializer.Serialize(span);
            lock (_lock)
            {
                File.AppendAllText(_tracesPath, line + Environment.NewLine);
            }
        }

        public void Dispose()
        {
            if (!_disposed)
            {
                _listener.Dispose();
                _disposed = true;
            }
        }
    }
    ```

    Modify LoggingConfiguration.cs to:
    - Add a `TraceFileListener?` field
    - Create TraceFileListener in Configure method (after setting up Serilog)
    - Dispose the listener in the cleanup/dispose path

    The listener will be created at host startup and live for the application lifetime.
  </action>
  <verify>
    Build the project. Verify LoggingConfiguration compiles with TraceFileListener integration.
  </verify>
  <done>
    TraceFileListener.cs exists and writes Activity spans to traces.json when ActivityStopped fires.
    LoggingConfiguration creates and owns TraceFileListener instance.
  </done>
</task>

</tasks>

<verification>
1. Build all affected projects: `dotnet build src/STIGForge.Infrastructure/`
2. Verify Telemetry namespace compiles correctly
3. Verify ActivitySource is configured to listen to "STIGForge.*" sources
4. Verify TraceFileListener properly implements IDisposable
</verification>

<success_criteria>
- MissionTracingService can start Activity spans with proper tags
- TraceContext captures current Activity for propagation
- TraceFileListener writes spans to traces.json file
- No new NuGet packages required (uses built-in System.Diagnostics)
- CorrelationIdEnricher continues to work with Activity.Current
</success_criteria>

<output>
After completion, create `.planning/phases/12-observability-integration/12-01-SUMMARY.md`
</output>
