---
phase: 04-human-resolution-and-evidence-continuity
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Evidence/EvidenceIndexService.cs
  - src/STIGForge.Evidence/EvidenceIndexModels.cs
  - src/STIGForge.Cli/Commands/EvidenceCommands.cs
  - tests/STIGForge.UnitTests/Evidence/EvidenceIndexServiceTests.cs
autonomous: true
requirements:
  - EVD-01
must_haves:
  truths:
    - "Operator can query all evidence artifacts for a specific control by control key"
    - "Evidence index includes SHA-256 checksums and full metadata for each artifact"
    - "Evidence index JSON manifest is written to Evidence/evidence_index.json in the bundle"
    - "Evidence lineage via SupersedesEvidenceId is traversable through the index"
  artifacts:
    - path: "src/STIGForge.Evidence/EvidenceIndexModels.cs"
      provides: "EvidenceIndex and EvidenceIndexEntry models"
      contains: "EvidenceIndex, EvidenceIndexEntry, ControlKey, Sha256, SupersedesEvidenceId"
    - path: "src/STIGForge.Evidence/EvidenceIndexService.cs"
      provides: "Evidence index building, querying, and manifest persistence"
      contains: "BuildIndexAsync, GetEvidenceForControl, GetEvidenceByType, GetEvidenceByRun, WriteIndexAsync"
    - path: "src/STIGForge.Cli/Commands/EvidenceCommands.cs"
      provides: "evidence-index CLI command"
      contains: "evidence-index, --bundle, --rebuild"
    - path: "tests/STIGForge.UnitTests/Evidence/EvidenceIndexServiceTests.cs"
      provides: "Tests for index building, querying, and lineage traversal"
      contains: "BuildIndex_ScansControlDirectories, QueryByControl_ReturnsMatches, Lineage_FollowsSupersedesChain"
  key_links:
    - from: "src/STIGForge.Evidence/EvidenceIndexService.cs"
      to: "EvidenceMetadata"
      via: "Reads .json metadata files from Evidence/by_control/ directories"
      pattern: "EvidenceMetadata.*Deserialize"
    - from: "src/STIGForge.Cli/Commands/EvidenceCommands.cs"
      to: "EvidenceIndexService"
      via: "BuildIndexAsync call"
      pattern: "BuildIndexAsync"
---

<objective>
Build an evidence index service that scans evidence directories, creates a queryable in-memory index, and writes a flat evidence_index.json manifest for downstream audit packaging.

Purpose: EVD-01 requires evidence autopilot with metadata and checksums suitable for audit packaging. The existing EvidenceCollector already writes per-control artifacts with SHA-256 hashes and metadata JSON files. This plan adds the index layer: scan all evidence, build a queryable index, write a manifest, and expose via CLI.
Output: EvidenceIndexService with build/query methods, EvidenceIndex model, evidence-index CLI command, unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-human-resolution-and-evidence-continuity/04-CONTEXT.md
@.planning/phases/04-human-resolution-and-evidence-continuity/04-RESEARCH.md
@src/STIGForge.Evidence/EvidenceCollector.cs
@src/STIGForge.Evidence/EvidenceModels.cs
@src/STIGForge.Evidence/EvidenceAutopilot.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EvidenceIndex models and EvidenceIndexService with build and query methods</name>
  <files>src/STIGForge.Evidence/EvidenceIndexModels.cs, src/STIGForge.Evidence/EvidenceIndexService.cs</files>
  <action>Create EvidenceIndexModels.cs with:

1. `EvidenceIndex` — top-level manifest model: `string BundleRoot`, `DateTimeOffset IndexedAt`, `int TotalEntries`, `List<EvidenceIndexEntry> Entries`.

2. `EvidenceIndexEntry` — flattened from EvidenceMetadata: `string EvidenceId` (basename without extension, from file name), `string ControlKey` (directory name under by_control/), `string? RuleId`, `string? ControlId`, `string? Title`, `string Type` (artifact type string), `string Source`, `string TimestampUtc`, `string Sha256`, `string RelativePath` (path relative to bundle Evidence/ dir), `string? RunId`, `string? StepName`, `string? SupersedesEvidenceId`, `Dictionary<string, string>? Tags`.

Create EvidenceIndexService.cs:

1. Constructor takes `string bundleRoot`.

2. `async Task<EvidenceIndex> BuildIndexAsync(CancellationToken ct = default)` — scan `{bundleRoot}/Evidence/by_control/` recursively. For each `.json` file (metadata files), deserialize as EvidenceMetadata. Build EvidenceIndexEntry from each metadata: set ControlKey from parent directory name, EvidenceId from file name without .json, RelativePath from the corresponding evidence file (same basename but different extension — find sibling file that isn't .json). Collect all entries, sort by ControlKey then TimestampUtc. Return populated EvidenceIndex with IndexedAt=UtcNow.

3. Query methods on EvidenceIndex (extension methods or instance methods on EvidenceIndexService):
   - `List<EvidenceIndexEntry> GetEvidenceForControl(string controlKey)` — filter entries by ControlKey (case-insensitive).
   - `List<EvidenceIndexEntry> GetEvidenceByType(string type)` — filter by Type.
   - `List<EvidenceIndexEntry> GetEvidenceByRun(string runId)` — filter by RunId.
   - `List<EvidenceIndexEntry> GetEvidenceByTag(string key, string value)` — filter entries whose Tags contain the key-value pair.
   - `List<EvidenceIndexEntry> GetLineageChain(string evidenceId)` — starting from an entry, follow SupersedesEvidenceId backwards to build the chain of prior evidence records.

4. `async Task WriteIndexAsync(EvidenceIndex index, CancellationToken ct = default)` — serialize to `{bundleRoot}/Evidence/evidence_index.json` with WriteIndented=true and camelCase naming. Overwrite if exists.</action>
  <verify>`dotnet build src/STIGForge.Evidence/STIGForge.Evidence.csproj` compiles. Grep for EvidenceIndexService in the Evidence project.</verify>
  <done>EvidenceIndex/EvidenceIndexEntry models exist. BuildIndexAsync scans evidence directories and reads metadata. Query methods filter by control/type/run/tag. GetLineageChain follows SupersedesEvidenceId. WriteIndexAsync writes evidence_index.json.</done>
</task>

<task type="auto">
  <name>Task 2: Add evidence-index CLI command and unit tests</name>
  <files>src/STIGForge.Cli/Commands/EvidenceCommands.cs, tests/STIGForge.UnitTests/Evidence/EvidenceIndexServiceTests.cs</files>
  <action>Create EvidenceCommands.cs following the DiffRebaseCommands.cs pattern (static class, Register method).

Register `evidence-index` command with options: `--bundle` (required, string — bundle root path), `--control` (optional, string — filter to specific control), `--type` (optional, string — filter by evidence type), `--run` (optional, string — filter by run ID), `--rebuild` (optional, bool — force rebuild even if index exists), `--json` (optional, bool — output as JSON instead of table).

Handler logic:
1. Create EvidenceIndexService with bundle root.
2. Check if evidence_index.json exists and --rebuild not set. If exists and no rebuild: read existing index. Otherwise: call BuildIndexAsync, then WriteIndexAsync.
3. Apply filters (--control, --type, --run) to narrow results.
4. If --json: serialize filtered entries as JSON. Else: print summary table: `{"ControlKey",-25} {"EvidenceId",-45} {"Type",-12} {"SHA-256 (first 16)",-18} {"Timestamp"}`. Print total count at bottom.

Register EvidenceCommands in the CLI root command registration alongside ManualCommands.

Create EvidenceIndexServiceTests.cs with xUnit tests:
- `BuildIndex_ScansControlDirectories` — set up temp bundle with 2 controls, each having an evidence file + .json metadata. Call BuildIndexAsync, assert 2 entries with correct ControlKeys.
- `QueryByControl_ReturnsMatches` — build index with 3 entries across 2 controls, query by one control key, assert correct subset.
- `QueryByType_FiltersCorrectly` — entries with mixed types, query by "Command", assert only command entries returned.
- `Lineage_FollowsSupersedesChain` — create 3 entries where C supersedes B, B supersedes A. Call GetLineageChain("C"), assert chain is [C, B, A].
- `WriteIndex_CreatesJsonFile` — build and write index, verify evidence_index.json exists and deserializes correctly.
- `QueryByRun_FiltersCorrectly` — entries with different RunIds, query by specific run, assert correct subset.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter EvidenceIndexService` — all tests pass. `dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj` compiles.</verify>
  <done>evidence-index CLI command builds and queries the evidence index. Filtered output works by control/type/run. 6 unit tests pass covering build, query, lineage, and write.</done>
</task>

</tasks>

<verification>
- `dotnet build` passes for Evidence and Cli projects
- `dotnet test --filter EvidenceIndexService` — all tests pass
- Manual verification: create temp bundle with evidence artifacts, run evidence-index --bundle, verify evidence_index.json created with correct entries
</verification>

<success_criteria>
- EvidenceIndexService scans Evidence/by_control/ and builds complete index
- evidence_index.json written as flat manifest with all entries
- Query by control/type/run/tag works correctly
- Lineage chain traversal follows SupersedesEvidenceId
- evidence-index CLI command functional with filter options
- 6 unit tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/04-human-resolution-and-evidence-continuity/04-02-SUMMARY.md`
</output>
