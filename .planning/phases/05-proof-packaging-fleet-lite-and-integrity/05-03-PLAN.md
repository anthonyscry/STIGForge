---
phase: 05-proof-packaging-fleet-lite-and-integrity
plan: 03
type: execute
wave: 2
depends_on: [05-01, 05-02]
files_modified:
  - src/STIGForge.Infrastructure/System/FleetService.cs
  - src/STIGForge.Infrastructure/Storage/AuditTrailService.cs
  - src/STIGForge.Cli/Commands/FleetCommands.cs
  - src/STIGForge.Cli/Commands/AuditCommands.cs
  - src/STIGForge.Export/EmassPackageValidator.cs
  - tests/STIGForge.UnitTests/Audit/FleetAuditTrailTests.cs
  - tests/STIGForge.UnitTests/Export/PackageIntegrityTests.cs
autonomous: true
requirements:
  - AUD-01
must_haves:
  truths:
    - "FleetService records audit entries for fleet-apply, fleet-verify, fleet-status, and fleet-collect operations"
    - "Per-host fleet operation results are recorded as individual audit entries with machine name in target field"
    - "Attestation import records an audit entry when operator merges filled attestation CSV"
    - "audit-verify validates the complete hash chain including fleet and attestation entries"
    - "EmassPackageValidator verifies packageHash matches SHA-256 of file_hashes.sha256"
    - "Package-level integrity verification is included in the validation report"
  artifacts:
    - path: "src/STIGForge.Infrastructure/System/FleetService.cs"
      provides: "Audit-aware FleetService with per-operation audit recording"
      contains: "IAuditTrailService, RecordAsync, fleet-apply, fleet-verify, fleet-collect"
    - path: "src/STIGForge.Cli/Commands/FleetCommands.cs"
      provides: "FleetCommands handlers pass IAuditTrailService to FleetService"
      contains: "IAuditTrailService, GetRequiredService, fleet-apply audit, fleet-collect audit"
    - path: "src/STIGForge.Cli/Commands/AuditCommands.cs"
      provides: "audit-integrity CLI command for package-level hash verification"
      contains: "audit-integrity, --package, packageHash verification"
    - path: "src/STIGForge.Export/EmassPackageValidator.cs"
      provides: "Package hash verification in validation pipeline"
      contains: "ValidatePackageHash, packageHash, file_hashes.sha256"
    - path: "tests/STIGForge.UnitTests/Audit/FleetAuditTrailTests.cs"
      provides: "Tests for fleet operation audit recording"
      contains: "FleetApply_RecordsAuditEntry, FleetVerify_RecordsPerHostEntries, ChainIntegrity_WithFleetEntries"
    - path: "tests/STIGForge.UnitTests/Export/PackageIntegrityTests.cs"
      provides: "Tests for package-level hash verification"
      contains: "PackageHash_ValidatesAgainstManifest, TamperedHashManifest_FailsValidation"
  key_links:
    - from: "src/STIGForge.Infrastructure/System/FleetService.cs"
      to: "IAuditTrailService"
      via: "optional constructor parameter, RecordAsync calls"
      pattern: "IAuditTrailService.*_audit"
    - from: "src/STIGForge.Export/EmassPackageValidator.cs"
      to: "packageHash"
      via: "reads from manifest.json, computes from file_hashes.sha256"
      pattern: "packageHash.*ValidatePackageHash"
---

<objective>
Complete audit trail coverage for fleet and attestation operations, and add package-level SHA-256 integrity verification.

Purpose: AUD-01 requires critical actions to be hash-chained and verifiable with package-level SHA-256 manifest completeness. The existing AuditTrailService has hash chaining and verification, and EmassExporter records export audit entries, but FleetService does not record audit entries, attestation import has no audit trail, and EmassPackageValidator does not verify the packageHash field. Per CONTEXT.md: fleet operations get audit entries, attestation acceptance is tracked, and package-level SHA-256 of file_hashes.sha256 is verified.
Output: Audit-aware FleetService, attestation import audit recording, packageHash verification in validator, audit-integrity CLI command, tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-proof-packaging-fleet-lite-and-integrity/05-CONTEXT.md
@.planning/phases/05-proof-packaging-fleet-lite-and-integrity/05-RESEARCH.md
@.planning/phases/05-proof-packaging-fleet-lite-and-integrity/05-01-PLAN.md
@.planning/phases/05-proof-packaging-fleet-lite-and-integrity/05-02-PLAN.md
@src/STIGForge.Infrastructure/System/FleetService.cs
@src/STIGForge.Infrastructure/Storage/AuditTrailService.cs
@src/STIGForge.Core/Abstractions/Services.cs
@src/STIGForge.Cli/Commands/FleetCommands.cs
@src/STIGForge.Cli/Commands/AuditCommands.cs
@src/STIGForge.Export/EmassPackageValidator.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IAuditTrailService to FleetService and record fleet operation audit entries</name>
  <files>src/STIGForge.Infrastructure/System/FleetService.cs, src/STIGForge.Cli/Commands/FleetCommands.cs</files>
  <action>In FleetService, add `IAuditTrailService? _audit` as a second optional constructor parameter (after ICredentialStore?). Update the constructor signature: `FleetService(ICredentialStore? credentialStore = null, IAuditTrailService? audit = null)`.

Add a private helper: `private async Task RecordAuditAsync(string action, string target, string result, string detail, CancellationToken ct)` that checks if _audit is not null and calls _audit.RecordAsync with a new AuditEntry. Wrap in try/catch to avoid audit failures blocking fleet operations (same pattern as EmassExporter).

Add audit recording at these points:

1. **ExecuteAsync**: After all machines complete, record one summary entry: Action = "fleet-{operation}" (e.g., "fleet-apply"), Target = comma-separated hostnames, Result = success count == total ? "success" : "partial", Detail = "Machines={total}, Success={n}, Failed={n}, Duration={seconds}s".

2. **ExecuteAsync per-host**: After each machine result, record individual entry: Action = "fleet-{operation}-host", Target = machineName, Result = success ? "success" : "failure", Detail = exitCode and truncated error.

3. **CollectArtifactsAsync** (added in plan 05-02): After collection completes, record summary entry: Action = "fleet-collect", Target = comma-separated hostnames, Result based on success count, Detail = files collected counts.

4. **CheckStatusAsync**: After status check, record: Action = "fleet-status", Target = comma-separated hostnames, Result based on reachable count, Detail = "Reachable={n}/{total}".

In FleetCommands.cs, update all handlers to resolve IAuditTrailService from DI and pass to FleetService constructor: `var audit = host.Services.GetService<IAuditTrailService>();` and `var svc = new FleetService(credStore, audit);`. The credential store resolution pattern already exists in some handlers — add audit consistently to all.</action>
  <verify>`dotnet build src/STIGForge.Infrastructure/STIGForge.Infrastructure.csproj` and `dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj` compile. Existing FleetService tests pass (new audit param is optional, no test changes needed).</verify>
  <done>FleetService records audit entries for all fleet operations. Per-host results are individually audited. FleetCommands handlers pass IAuditTrailService from DI.</done>
</task>

<task type="auto">
  <name>Task 2: Add attestation import audit trail and package hash verification to EmassPackageValidator</name>
  <files>src/STIGForge.Export/AttestationImporter.cs, src/STIGForge.Export/EmassPackageValidator.cs, src/STIGForge.Cli/Commands/ExportCommands.cs</files>
  <action>In AttestationImporter.ImportAttestations (created in plan 05-01), add an optional `IAuditTrailService? audit = null` parameter. After merge completes, if audit is not null, record: Action = "import-attestations", Target = packageRoot, Result = "success", Detail = "Updated={n}, Skipped={n}, NotFound={n}". In ExportCommands.cs import-attestations handler, resolve IAuditTrailService and pass to ImportAttestations.

In EmassPackageValidator, add a new method `ValidatePackageHash(string root, List<string> errors, List<string> warnings, ValidationMetrics metrics)` called from ValidatePackage after ValidateFileHashes:

1. Read manifest.json and extract `packageHash` field.
2. If packageHash is present: compute SHA-256 of `00_Manifest/file_hashes.sha256`, compare to packageHash. If mismatch: add error "Package hash mismatch: hash manifest has been modified after package creation".
3. If packageHash is absent: add warning "No packageHash in manifest — package integrity cannot be verified at package level".

Add `bool PackageHashValid` and `string? PackageHashExpected` and `string? PackageHashActual` to ValidationMetrics for reporting.

Update WriteValidationReport to include a PACKAGE INTEGRITY section:
```
PACKAGE INTEGRITY:
  Package hash: VALID (matches file_hashes.sha256)
  Hash chain entries: {count}
  File hash mismatches: {count}
```</action>
  <verify>`dotnet build src/STIGForge.Export/STIGForge.Export.csproj` and `dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj` compile. Existing validator tests pass.</verify>
  <done>Attestation import records audit entries. EmassPackageValidator verifies packageHash against file_hashes.sha256 with clear error on mismatch. Validation report includes package integrity section.</done>
</task>

<task type="auto">
  <name>Task 3: Add audit-integrity CLI command for package-level verification</name>
  <files>src/STIGForge.Cli/Commands/AuditCommands.cs</files>
  <action>Add a new `audit-integrity` CLI command registered in AuditCommands.Register:

Options: `--package` (required, eMASS package root path), `--json` (optional, JSON output).

Handler:
1. Instantiate EmassPackageValidator.
2. Call ValidatePackage(packageRoot).
3. Additionally, resolve IAuditTrailService and call VerifyIntegrityAsync to check the audit trail chain.
4. Display combined integrity report:
   - Package validation result (VALID/INVALID with errors/warnings)
   - Package hash verification (MATCH/MISMATCH)
   - Audit trail chain integrity (VALID/INVALID)
   - Submission readiness status
5. If --json, output as structured JSON object with all four sections.
6. Set exit code 1 if any check fails.

This gives operators a single command to verify the complete integrity of a submission package and its audit trail.</action>
  <verify>`dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj` compiles. `dotnet run --project src/STIGForge.Cli -- audit-integrity --help` shows correct options.</verify>
  <done>audit-integrity CLI command provides single-command verification of package integrity, package hash, audit trail chain, and submission readiness.</done>
</task>

<task type="auto">
  <name>Task 4: Add fleet audit trail and package integrity tests</name>
  <files>tests/STIGForge.UnitTests/Audit/FleetAuditTrailTests.cs, tests/STIGForge.UnitTests/Export/PackageIntegrityTests.cs</files>
  <action>Create FleetAuditTrailTests.cs with xUnit tests using a real AuditTrailService backed by in-memory SQLite (same pattern as existing AuditTrailServiceTests):

1. `FleetExecute_RecordsSummaryAuditEntry` — create FleetService with audit, execute fleet-apply with mock targets (will fail since no real hosts, but that's fine). Verify audit trail contains a "fleet-apply" action entry.
2. `FleetExecute_RecordsPerHostEntries` — execute with 2 targets. Verify audit trail contains "fleet-apply-host" entries for each host.
3. `FleetStatus_RecordsAuditEntry` — call CheckStatusAsync with mock targets. Verify "fleet-status" audit entry recorded.
4. `ChainIntegrity_ValidAfterFleetEntries` — record several fleet entries, then call VerifyIntegrityAsync. Assert returns true.
5. `AttestationImport_RecordsAuditEntry` — create test attestation files, call ImportAttestations with audit. Verify "import-attestations" audit entry with correct counts in detail.

Create PackageIntegrityTests.cs:

1. `PackageHash_ValidatesAgainstManifest` — create a complete test eMASS package directory (use EmassExporter to generate it from a mock bundle), run EmassPackageValidator.ValidatePackage. Verify PackageHashValid is true in metrics.
2. `TamperedHashManifest_FailsValidation` — create valid package, then modify file_hashes.sha256 (add a line). Run validator. Verify packageHash error in results.
3. `MissingPackageHash_WarnsButDoesNotFail` — create package without packageHash in manifest. Verify warning but IsValid is still true (other checks pass).
4. `SubmissionReadiness_InValidationReport` — create package with submissionReadiness in manifest. Write validation report. Verify SUBMISSION READINESS and PACKAGE INTEGRITY sections appear.
5. `FullIntegrity_EndToEnd` — create a package, verify all checks pass (package valid, packageHash valid, no errors). This is the happy path test.

Use temp directories and in-memory SQLite for all tests.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "FleetAuditTrail|PackageIntegrity"` — all tests pass.</verify>
  <done>Fleet audit trail tests verify per-operation recording and chain integrity. Package integrity tests verify packageHash validation, tamper detection, and submission readiness reporting.</done>
</task>

</tasks>

<verification>
- `dotnet build` passes for all projects
- `dotnet test --filter "FleetAuditTrail|PackageIntegrity|AuditTrailService|EmassPackageValidator"` — all tests pass (new and existing)
- `audit-integrity --help` shows correct options
- audit-verify still validates chain including fleet entries
- Package with tampered hash manifest fails validation
</verification>

<success_criteria>
AUD-01 is satisfied: fleet operations record hash-chained audit entries, attestation import is audited, package-level SHA-256 of file_hashes.sha256 is verified by EmassPackageValidator, and audit-integrity CLI provides single-command verification of complete package and audit trail integrity.
</success_criteria>

<output>
After completion, create `.planning/phases/05-proof-packaging-fleet-lite-and-integrity/05-03-SUMMARY.md`
</output>
