---
phase: 02-apply-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Cli/Commands/ProfileCommands.cs
  - src/STIGForge.Cli/Program.cs
  - src/STIGForge.Core/Services/ProfileValidator.cs
  - tests/STIGForge.UnitTests/Services/ProfileValidatorTests.cs
  - tests/STIGForge.UnitTests/Cli/ProfileCommandsTests.cs
autonomous: true
requirements:
  - POL-01
must_haves:
  truths:
    - "Operator can list all profiles with id, name, classification mode, and hardening mode"
    - "Operator can show full profile details including NaPolicy and AutomationPolicy knobs"
    - "Operator can create a profile from a JSON file and persist it to the repository"
    - "Operator can export a profile to JSON for backup or transfer"
    - "Profile validation catches invalid policy values before they reach build"
  artifacts:
    - path: "src/STIGForge.Cli/Commands/ProfileCommands.cs"
      provides: "CLI commands for profile list, show, create, update, export, validate"
      contains: "RegisterProfileList, RegisterProfileShow, RegisterProfileCreate"
    - path: "src/STIGForge.Core/Services/ProfileValidator.cs"
      provides: "Profile validation logic for policy consistency"
      contains: "Validate"
    - path: "tests/STIGForge.UnitTests/Services/ProfileValidatorTests.cs"
      provides: "Validation tests for edge cases"
      contains: "NegativeGraceDays_Fails, NullNaPolicy_Fails"
  key_links:
    - from: "src/STIGForge.Cli/Program.cs"
      to: "ProfileCommands"
      via: "Register() call"
      pattern: "ProfileCommands.Register"
    - from: "src/STIGForge.Cli/Commands/ProfileCommands.cs"
      to: "IProfileRepository"
      via: "DI resolution"
      pattern: "GetRequiredService.*IProfileRepository"
---

<objective>
Surface profile management through CLI commands so operators can configure, inspect, and validate policy knobs at rest.

Purpose: Operators need to create, view, edit, and export profiles with deterministic policy knobs (POL-01) before executing builds. Profile is the single carrier for all policy dimensions.
Output: ProfileCommands.cs with full CRUD, ProfileValidator for consistency checking, unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-apply-logic/02-RESEARCH.md
@.planning/phases/02-apply-logic/02-CONTEXT.md
@src/STIGForge.Core/Models/Profile.cs
@src/STIGForge.Core/Abstractions/Repositories.cs
@src/STIGForge.Cli/Commands/BuildCommands.cs
@src/STIGForge.Cli/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProfileValidator service and tests</name>
  <files>src/STIGForge.Core/Services/ProfileValidator.cs, tests/STIGForge.UnitTests/Services/ProfileValidatorTests.cs</files>
  <action>Create `ProfileValidator` in STIGForge.Core.Services with a `Validate(Profile)` method returning a `ProfileValidationResult` (bool IsValid, IReadOnlyList of string Errors). Validate: ProfileId not null/empty, Name not null/empty, NaPolicy not null, AutomationPolicy not null, NewRuleGraceDays >= 0, ConfidenceThreshold is valid enum, ClassificationMode is valid enum, OverlayIds contains no null/empty entries. Return all errors (not just first). Add unit tests covering: valid profile passes, null NaPolicy fails, negative grace days fails, empty ProfileId fails, null OverlayId entry fails, multiple errors accumulate. Use xUnit + FluentAssertions pattern from existing OverlayRebaseServiceTests.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter ProfileValidator`</verify>
  <done>ProfileValidator catches all invalid policy states with descriptive error messages, and all validation tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Implement profile CLI commands</name>
  <files>src/STIGForge.Cli/Commands/ProfileCommands.cs, src/STIGForge.Cli/Program.cs, tests/STIGForge.UnitTests/Cli/ProfileCommandsTests.cs</files>
  <action>Create `ProfileCommands` static class following the BuildCommands.Register() pattern with System.CommandLine. Register a `profile` parent command with subcommands: (1) `list` — resolve IProfileRepository, call ListAsync, output table with columns ProfileId, Name, ClassificationMode, HardeningMode, GraceDays; (2) `show <id>` — GetAsync, output all profile fields including NaPolicy and AutomationPolicy as formatted text; (3) `create --from-json <path>` with optional `--save` flag — deserialize Profile from JSON file, run ProfileValidator.Validate(), reject if invalid with error list, save to repository if --save; (4) `update <id> --from-json <path>` — load existing, deserialize updates, validate, save; (5) `export <id> --output <path>` — GetAsync, serialize to JSON with WriteIndented, write to file; (6) `validate <id>` or `validate --from-json <path>` — run ProfileValidator, output pass/fail with error list. Wire ProfileCommands.Register() into Program.cs alongside existing BuildCommands.Register(). Add integration tests for create-from-json validation failure and list output format.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "ProfileValidator|ProfileCommand"` and `dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj`</verify>
  <done>All six profile subcommands compile, wire through DI, and handle happy-path and validation-failure scenarios. CLI outputs tabular profile list and structured profile details.</done>
</task>

</tasks>

<verification>
Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "ProfileValidator|ProfileCommand"` and confirm all tests pass. Build CLI with `dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj` and verify `--help` shows profile subcommands.
</verification>

<success_criteria>
Operators can manage profiles through CLI with full CRUD operations. Profile validation catches invalid policy configurations before they reach the build pipeline. Determinism contract is enforced: same profile JSON always produces the same persisted profile.
</success_criteria>

<output>
After completion, create `.planning/phases/02-apply-logic/02-01-SUMMARY.md`
</output>
