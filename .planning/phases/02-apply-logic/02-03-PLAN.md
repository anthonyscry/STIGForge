---
phase: 02-apply-logic
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Core/Services/OverlayConflictDetector.cs
  - src/STIGForge.Build/BundleBuilder.cs
  - tests/STIGForge.UnitTests/Services/OverlayConflictDetectorTests.cs
autonomous: true
requirements:
  - POL-02
must_haves:
  truths:
    - "When multiple overlays override the same control, positional precedence determines the winner (last wins)"
    - "Overlay conflict report is deterministic — same overlays in same order always produce identical CSV"
    - "Blocking conflicts halt bundle build with explicit error listing conflicting controls"
    - "overlay_conflict_report.csv is emitted in Reports/ directory alongside na_scope_filter_report.csv"
  artifacts:
    - path: "src/STIGForge.Core/Services/OverlayConflictDetector.cs"
      provides: "Multi-overlay conflict detection with positional precedence"
      contains: "DetectConflicts, OverlayConflict"
    - path: "src/STIGForge.Build/BundleBuilder.cs"
      provides: "overlay_conflict_report.csv emission and blocking conflict enforcement"
      contains: "overlay_conflict_report.csv, WriteOverlayConflictReport"
    - path: "tests/STIGForge.UnitTests/Services/OverlayConflictDetectorTests.cs"
      provides: "Conflict detection and determinism tests"
      contains: "TwoOverlays_SameControl_LastWins, BlockingConflict_DifferentStatus"
  key_links:
    - from: "src/STIGForge.Build/BundleBuilder.cs"
      to: "OverlayConflictDetector"
      via: "DetectConflicts() call during build"
      pattern: "_conflictDetector.DetectConflicts"
    - from: "src/STIGForge.Build/BundleBuilder.cs"
      to: "Reports/overlay_conflict_report.csv"
      via: "WriteOverlayConflictReport()"
      pattern: "overlay_conflict_report.csv"
---

<objective>
Implement overlay conflict detection and integrate it into the bundle build pipeline with deterministic reporting.

Purpose: POL-02 requires overlay precedence and conflict resolution to be deterministic and reportable. When multiple overlays override the same control with different values, the operator needs to see which overlay won and why, and blocking conflicts must halt the build.
Output: OverlayConflictDetector service, overlay_conflict_report.csv emission in BundleBuilder, unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-apply-logic/02-RESEARCH.md
@.planning/phases/02-apply-logic/02-CONTEXT.md
@src/STIGForge.Core/Models/Overlay.cs
@src/STIGForge.Core/Models/Profile.cs
@src/STIGForge.Core/Services/OverlayRebaseService.cs
@src/STIGForge.Build/BundleBuilder.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OverlayConflictDetector service with positional precedence</name>
  <files>src/STIGForge.Core/Services/OverlayConflictDetector.cs, tests/STIGForge.UnitTests/Services/OverlayConflictDetectorTests.cs</files>
  <action>Create `OverlayConflictDetector` in STIGForge.Core.Services with:

**Model classes (in same file):**
- `OverlayConflict` with properties: ControlKey (string), WinningOverlayId (string), OverriddenOverlayId (string), WinningValue (string), OverriddenValue (string), Reason (string), IsBlockingConflict (bool).
- `OverlayConflictReport` with properties: Conflicts (IReadOnlyList of OverlayConflict), HasBlockingConflicts (bool), BlockingConflictCount (int).

**DetectConflicts method:**
- Takes `IReadOnlyList<Overlay> overlays` (ordered by Profile.OverlayIds position — index 0 is lowest priority, last is highest).
- For each control key (prefer RuleId, fallback to VulnId), collect all overlay overrides.
- When multiple overlays touch the same control: the one with the highest index wins (last-wins positional precedence).
- Create an OverlayConflict entry for each overridden overlay.
- Blocking conflict: when winning and overridden overlays have different StatusOverride values (one says NotApplicable, other says Open — genuine disagreement on compliance status).
- Non-blocking conflict: same StatusOverride but different NaReason or Notes — informational, does not halt build.
- Format WinningValue/OverriddenValue as "Status={status}, NaReason={reason}" for readability.
- Sort output by ControlKey (OrdinalIgnoreCase), then by OverriddenOverlayId for deterministic ordering.

**Unit tests:**
- NoOverlays_EmptyReport
- SingleOverlay_NoConflicts
- TwoOverlays_SameControl_LastWins — verify winner is the higher-index overlay
- TwoOverlays_DifferentStatus_IsBlockingConflict — one has StatusOverride=NotApplicable, other has null (Open)
- TwoOverlays_SameStatus_NonBlocking — same StatusOverride, different NaReason
- ThreeOverlays_SameControl_HighestIndexWins — three overlays on one control, verify only highest wins
- DeterministicOutput — same inputs twice produce identical report
- ControlKey_PrefersRuleId_FallsBackToVulnId

Use xUnit + FluentAssertions.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter OverlayConflictDetector`</verify>
  <done>OverlayConflictDetector correctly identifies conflicts with positional precedence, flags blocking conflicts, and produces deterministic output.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate overlay conflict detection into BundleBuilder</name>
  <files>src/STIGForge.Build/BundleBuilder.cs</files>
  <action>Add `OverlayConflictDetector` as a constructor parameter to BundleBuilder (alongside existing _paths, _hash, _scope, _releaseGate). In BuildAsync():

1. After loading overlays, call `_conflictDetector.DetectConflicts(request.Overlays)`.
2. Write `overlay_conflict_report.csv` to Reports/ directory using the same `Csv()` helper and pattern as `WriteNaScopeReport()`. CSV columns: ControlKey, WinningOverlayId, OverriddenOverlayId, WinningValue, OverriddenValue, Reason. Order by ControlKey then OverriddenOverlayId (deterministic).
3. If `report.HasBlockingConflicts` is true AND `request.ForceAutoApply` is false: throw `InvalidOperationException` with message listing each blocking conflict's ControlKey and the conflicting overlay IDs. Message format: "Overlay conflicts block build: {ControlKey} (overlays {WinningId} vs {OverriddenId})".
4. If `report.HasBlockingConflicts` is true AND `request.ForceAutoApply` is true: write report but continue (break-glass allows proceeding past blocking conflicts).
5. Always write the CSV even if no conflicts (empty CSV with header row only).

Update DI registrations in CliHostFactory.cs and App.xaml.cs to register OverlayConflictDetector as a singleton. Ensure existing BundleBuilder tests and usages still compile by updating constructor calls.</action>
  <verify>`dotnet build src/STIGForge.Build/STIGForge.Build.csproj && dotnet build src/STIGForge.Cli/STIGForge.Cli.csproj`</verify>
  <done>BundleBuilder emits overlay_conflict_report.csv in Reports/ directory, halts on blocking conflicts unless break-glass override is active, and all existing build paths compile.</done>
</task>

</tasks>

<verification>
Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "OverlayConflictDetector|BundleBuilder"` and confirm all tests pass. Build both CLI and App projects to verify DI wiring compiles.
</verification>

<success_criteria>
Overlay conflict detection follows positional precedence (last wins), produces deterministic CSV reports, and blocking conflicts halt the build with explicit error. The report integrates into the existing Reports/ directory pattern alongside na_scope_filter_report.csv.
</success_criteria>

<output>
After completion, create `.planning/phases/02-apply-logic/02-03-SUMMARY.md`
</output>
