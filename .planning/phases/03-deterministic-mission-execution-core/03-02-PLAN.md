---
phase: 03-deterministic-mission-execution-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tools/apply/Preflight/Preflight.ps1
  - src/STIGForge.Apply/PreflightRunner.cs
  - src/STIGForge.Apply/ApplyModels.cs
  - tests/STIGForge.UnitTests/Apply/PreflightRunnerTests.cs
autonomous: true
requirements:
  - APL-01
must_haves:
  truths:
    - "Preflight blocks execution when PowerSTIG module cannot be imported"
    - "Preflight blocks execution when required DSC resources are missing or version-mismatched"
    - "Preflight blocks execution when both DSC and LGPO targets exist for the same control"
    - "C# PreflightRunner invokes Preflight.ps1 and interprets exit code and JSON output"
    - "All existing preflight checks (admin, OS, disk, PowerShell, reboot, CLM, execution policy) continue to work"
  artifacts:
    - path: "tools/apply/Preflight/Preflight.ps1"
      provides: "Extended preflight with PowerSTIG, DSC resource, and mutual-exclusion checks"
      contains: "Test-PowerStigAvailable, Test-DscResources, Test-MutualExclusion"
    - path: "src/STIGForge.Apply/PreflightRunner.cs"
      provides: "C# wrapper that invokes preflight script and parses results"
      contains: "RunPreflightAsync, PreflightResult"
    - path: "tests/STIGForge.UnitTests/Apply/PreflightRunnerTests.cs"
      provides: "Unit tests for preflight C# runner"
      contains: "SuccessfulPreflight_ReturnsOk, FailedPreflight_ReturnsIssues"
  key_links:
    - from: "src/STIGForge.Apply/PreflightRunner.cs"
      to: "tools/apply/Preflight/Preflight.ps1"
      via: "Process.Start with powershell.exe"
      pattern: "Preflight\\.ps1"
    - from: "src/STIGForge.Apply/PreflightRunner.cs"
      to: "PreflightResult"
      via: "JSON deserialization of script output"
      pattern: "JsonSerializer.Deserialize.*PreflightResult"
---

<objective>
Harden the apply preflight gate so unsafe execution states are blocked with explicit operator-visible failure reasons before any host changes occur.

Purpose: APL-01 requires that apply preflight enforces elevation/compatibility/reboot/PowerShell safety checks. The existing Preflight.ps1 has core checks but lacks PowerSTIG module availability, DSC resource version verification, and DSC/LGPO mutual-exclusion safety. There is no C# wrapper to invoke preflight and interpret results — the orchestrator just passes it as a script arg. Per CONTEXT.md decision: "No C# preflight duplication — PowerShell preflight is the single source of truth, C# just invokes and checks exit code."
Output: Extended Preflight.ps1 with three new checks; PreflightRunner.cs C# wrapper; unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-deterministic-mission-execution-core/03-CONTEXT.md
@.planning/phases/03-deterministic-mission-execution-core/03-RESEARCH.md
@tools/apply/Preflight/Preflight.ps1
@src/STIGForge.Apply/ApplyRunner.cs
@src/STIGForge.Apply/ApplyModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Preflight.ps1 with PowerSTIG, DSC resource, and mutual-exclusion checks</name>
  <files>tools/apply/Preflight/Preflight.ps1</files>
  <action>Add three new check functions to Preflight.ps1 after the existing checks, preserving all current functionality. (1) `Test-PowerStigAvailable`: attempt `Import-Module PowerSTIG -ErrorAction SilentlyContinue`; if module not found, add issue "PowerSTIG module not available". Only run this check if a new optional param `[string]$PowerStigModulePath` is provided (default empty string). (2) `Test-DscResources`: if `$PowerStigModulePath` is provided, parse the module manifest for required DSC resources and verify each is available via `Get-DscResource -Name $name -ErrorAction SilentlyContinue`. For each missing resource, add issue "DSC resource missing: $name". Also check that the installed version meets the minimum if the manifest specifies one. (3) `Test-MutualExclusion`: add optional param `[switch]$CheckLgpoConflict` and `[string]$BundleManifestPath`. If both are provided, read the manifest JSON, check if any controls have both DSC and LGPO remediation targets. If conflicts found, add issue "Mutual exclusion conflict: controls $ids have both DSC and LGPO targets". Update the param block to include the new optional parameters. Ensure backward compatibility: existing callers that only pass `-BundleRoot` and `-ModulesPath` still work. Change the output PSCustomObject to include an `ExitCode` property: 0 if Ok, 1 if issues found. At the end, `exit $result.ExitCode` so the C# wrapper can read the exit code. Output the result JSON to stdout with `$result | ConvertTo-Json -Depth 5`.</action>
  <verify>Review the updated Preflight.ps1 to confirm all existing checks remain and new checks are added with proper parameter defaults.</verify>
  <done>Preflight.ps1 has three new checks (PowerSTIG module, DSC resources, mutual-exclusion), outputs JSON to stdout, and exits with code 0/1.</done>
</task>

<task type="auto">
  <name>Task 2: Create PreflightRunner C# wrapper and unit tests</name>
  <files>src/STIGForge.Apply/PreflightRunner.cs, src/STIGForge.Apply/ApplyModels.cs, tests/STIGForge.UnitTests/Apply/PreflightRunnerTests.cs</files>
  <action>Create `PreflightRunner` in STIGForge.Apply namespace. Constructor takes `ILogger<PreflightRunner>`. Method: `Task<PreflightResult> RunPreflightAsync(PreflightRequest request, CancellationToken ct)`. PreflightRequest has: BundleRoot (required), ModulesPath (optional), PowerStigModulePath (optional), CheckLgpoConflict (bool), BundleManifestPath (optional). Implementation: locate Preflight.ps1 at `Path.Combine(request.BundleRoot, "Apply", "Preflight", "Preflight.ps1")`; if not found, return PreflightResult with Ok=false, Issues=["Preflight script not found"]. Build powershell.exe arguments: `-NoProfile -ExecutionPolicy Bypass -File "{path}" -BundleRoot "{bundleRoot}" -ModulesPath "{modulesPath}"` plus optional params. Start process, capture stdout/stderr, wait with 60s timeout. Parse stdout JSON into PreflightResult. If exit code != 0 or parse fails, construct PreflightResult from raw output. Add PreflightResult and PreflightRequest to ApplyModels.cs: `PreflightResult { bool Ok, IReadOnlyList<string> Issues, string Timestamp, int ExitCode }`, `PreflightRequest { string BundleRoot, string? ModulesPath, string? PowerStigModulePath, bool CheckLgpoConflict, string? BundleManifestPath }`. In unit tests, test: (1) missing script returns not-ok with descriptive issue, (2) successful JSON parse returns PreflightResult correctly, (3) non-zero exit code surfaces issues. Use a temp directory with a mock Preflight.ps1 that outputs known JSON for integration-style tests.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter PreflightRunner` — all tests pass. `dotnet build src/STIGForge.Apply/STIGForge.Apply.csproj` compiles.</verify>
  <done>PreflightRunner invokes Preflight.ps1, parses JSON output, and returns structured PreflightResult. Missing script, timeout, and parse failure cases are handled gracefully.</done>
</task>

</tasks>

<verification>
Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter PreflightRunner` and confirm all tests pass. Verify Preflight.ps1 still has all original checks plus three new ones. Build solution with `dotnet build` and confirm no regressions.
</verification>

<success_criteria>
APL-01 preflight enforcement is complete: PowerSTIG module, DSC resources, and mutual-exclusion checks block unsafe states. C# wrapper provides structured access to preflight results. Existing preflight behavior is preserved.
</success_criteria>

<output>
After completion, create `.planning/phases/03-deterministic-mission-execution-core/03-02-SUMMARY.md`
</output>
