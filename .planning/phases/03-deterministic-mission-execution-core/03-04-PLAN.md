---
phase: 03-deterministic-mission-execution-core
plan: 04
type: execute
wave: 2
depends_on: [03-02]
files_modified:
  - src/STIGForge.Apply/Lgpo/LgpoRunner.cs
  - src/STIGForge.Apply/Lgpo/LgpoModels.cs
  - src/STIGForge.Apply/ApplyRunner.cs
  - src/STIGForge.Apply/ApplyModels.cs
  - src/STIGForge.Apply/ApplyFallbackHandler.cs
  - src/STIGForge.Apply/Reboot/RebootCoordinator.cs
  - src/STIGForge.Apply/Reboot/RebootModels.cs
  - tests/STIGForge.UnitTests/Apply/LgpoRunnerTests.cs
  - tests/STIGForge.UnitTests/Apply/ApplyConvergenceTests.cs
autonomous: true
requirements:
  - APL-02
must_haves:
  truths:
    - "Operator can run apply through DSC (primary), LGPO (secondary), or script (fallback) backends"
    - "LGPO backend wraps LGPO.exe for policy import with machine/user scope"
    - "ApplyResult includes rebootCount and convergenceStatus (converged/diverged/exceeded)"
    - "Maximum 3 reboots per apply cycle — exceeding triggers abort with max_reboot_exceeded error"
    - "Post-reboot preflight checks run before resuming apply steps"
    - "Fallback chain order is DSC -> LGPO -> Script -> Manual with no retry logic"
  artifacts:
    - path: "src/STIGForge.Apply/Lgpo/LgpoRunner.cs"
      provides: "LGPO.exe wrapper for policy import and export"
      contains: "ApplyPolicyAsync, ExportPolicyAsync"
    - path: "src/STIGForge.Apply/Lgpo/LgpoModels.cs"
      provides: "LGPO request/result models"
      contains: "LgpoApplyRequest, LgpoApplyResult, LgpoScope"
    - path: "src/STIGForge.Apply/ApplyRunner.cs"
      provides: "Extended runner with LGPO step and convergence tracking"
      contains: "apply_lgpo, ConvergenceStatus, RebootCount"
    - path: "tests/STIGForge.UnitTests/Apply/LgpoRunnerTests.cs"
      provides: "LGPO runner unit tests"
      contains: "ApplyPolicy_InvokesLgpoExe, MissingLgpoExe_ThrowsFileNotFound"
    - path: "tests/STIGForge.UnitTests/Apply/ApplyConvergenceTests.cs"
      provides: "Convergence tracking and max reboot tests"
      contains: "MaxReboots_Exceeded_Aborts, ConvergenceStatus_Converged"
  key_links:
    - from: "src/STIGForge.Apply/ApplyRunner.cs"
      to: "LgpoRunner"
      via: "optional constructor param"
      pattern: "LgpoRunner.*lgpoRunner"
    - from: "src/STIGForge.Apply/ApplyRunner.cs"
      to: "RebootCoordinator"
      via: "reboot count tracking"
      pattern: "rebootCount.*MaxReboots"
    - from: "src/STIGForge.Apply/ApplyFallbackHandler.cs"
      to: "ApplyRunner step names"
      via: "fallback chain DSC -> LGPO -> Script -> Manual"
      pattern: "DSC.*LGPO.*Script.*Manual"
---

<objective>
Enable multi-backend apply execution with LGPO support, reboot-aware convergence tracking, and ordered fallback chain.

Purpose: APL-02 requires PowerSTIG/DSC primary backend, optional GPO/LGPO path, and script fallback with reboot-aware convergence. The existing ApplyRunner has DSC and script backends but no LGPO. RebootCoordinator detects reboots but has no max reboot counter or post-reboot preflight. Per CONTEXT.md decisions: LGPO runner wraps LGPO.exe, fallback order is DSC -> LGPO -> Script -> Manual, no adaptive switching, max 3 reboots, post-reboot preflight re-runs.
Output: LgpoRunner, extended ApplyRunner with LGPO step and convergence tracking, updated RebootCoordinator with max reboot enforcement, tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-deterministic-mission-execution-core/03-CONTEXT.md
@.planning/phases/03-deterministic-mission-execution-core/03-RESEARCH.md
@.planning/phases/03-deterministic-mission-execution-core/03-02-SUMMARY.md
@src/STIGForge.Apply/ApplyRunner.cs
@src/STIGForge.Apply/ApplyModels.cs
@src/STIGForge.Apply/ApplyFallbackHandler.cs
@src/STIGForge.Apply/Reboot/RebootCoordinator.cs
@src/STIGForge.Apply/Reboot/RebootModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LgpoRunner and models, extend ApplyRunner with LGPO step and convergence</name>
  <files>src/STIGForge.Apply/Lgpo/LgpoRunner.cs, src/STIGForge.Apply/Lgpo/LgpoModels.cs, src/STIGForge.Apply/ApplyRunner.cs, src/STIGForge.Apply/ApplyModels.cs</files>
  <action>Create `Lgpo/` directory under STIGForge.Apply. (1) LgpoModels.cs: `LgpoScope` enum (Machine, User), `LgpoApplyRequest` (string PolFilePath, LgpoScope Scope, string? LgpoExePath), `LgpoApplyResult` (bool Success, int ExitCode, string StdOut, string StdErr, DateTimeOffset StartedAt, DateTimeOffset FinishedAt). (2) LgpoRunner.cs: sealed class, constructor takes `ILogger<LgpoRunner>`. Method `Task<LgpoApplyResult> ApplyPolicyAsync(LgpoApplyRequest request, CancellationToken ct)`: resolve LGPO.exe path (default: `tools/LGPO.exe` relative to bundle, or request.LgpoExePath override). If not found, throw FileNotFoundException. Build args: `/m "{polPath}"` for Machine scope, `/u "{polPath}"` for User scope. Start process, capture stdout/stderr, wait 60s timeout. Return result. Method `Task<string> ExportPolicyAsync(LgpoScope scope, string outputDir, CancellationToken ct)`: invoke LGPO.exe `/parse /m` or `/parse /u`, write output to file, return path. (3) In ApplyModels.cs: add `string? LgpoPolFilePath` and `LgpoScope? LgpoScope` and `string? LgpoExePath` to ApplyRequest. Add `int RebootCount` and `ConvergenceStatus ConvergenceStatus` to ApplyResult. Add `ConvergenceStatus` enum: `Converged, Diverged, Exceeded, NotApplicable`. (4) In ApplyRunner: add `LgpoRunner? _lgpoRunner` as optional constructor param. Add const `LgpoStepName = "apply_lgpo"`. After the DSC step block and before the final summary, add LGPO step block following the same pattern as DSC (check completedSteps, run, write evidence, check reboot). Add convergence tracking: count reboots from resume context (CompletedSteps reboot cycles) + current run. Set ConvergenceStatus on the final ApplyResult: Converged if all steps completed with no pending reboot, Diverged if steps completed but issues remain, Exceeded if max reboots hit. Add `RebootCount` to ApplyResult from the tracking count.</action>
  <verify>`dotnet build src/STIGForge.Apply/STIGForge.Apply.csproj` compiles cleanly.</verify>
  <done>LgpoRunner wraps LGPO.exe for apply and export. ApplyRunner has LGPO step slot. ApplyResult carries rebootCount and convergenceStatus.</done>
</task>

<task type="auto">
  <name>Task 2: Enforce max reboot limit, post-reboot preflight, and add tests</name>
  <files>src/STIGForge.Apply/Reboot/RebootCoordinator.cs, src/STIGForge.Apply/Reboot/RebootModels.cs, src/STIGForge.Apply/ApplyRunner.cs, src/STIGForge.Apply/ApplyFallbackHandler.cs, tests/STIGForge.UnitTests/Apply/LgpoRunnerTests.cs, tests/STIGForge.UnitTests/Apply/ApplyConvergenceTests.cs</files>
  <action>(1) In RebootModels.cs, add `int RebootCount` to RebootContext. (2) In RebootCoordinator, add `public const int MaxReboots = 3`. In ScheduleReboot, before writing the marker: check `context.RebootCount >= MaxReboots`. If exceeded, throw `RebootException("Maximum reboot count (3) exceeded for apply cycle. Aborting. Error: max_reboot_exceeded")`. Increment RebootCount in context before writing. In ResumeAfterReboot, after reading context, log the reboot count. (3) In ApplyRunner, after each reboot detection block (PowerSTIG, Script, DSC, LGPO): before calling ScheduleReboot, read current reboot count from resume context or initialize to 0, then set `context.RebootCount = currentRebootCount + 1`. After ResumeAfterReboot succeeds, add a step to invoke PreflightRunner (from plan 03-02) if available — add `PreflightRunner? _preflightRunner` as optional constructor param. If preflight fails after reboot resume, throw with "Post-reboot preflight failed" and the issues. (4) In ApplyFallbackHandler, update the doc comment to reflect the full chain: DSC (primary) -> LGPO (secondary) -> Script (fallback) -> Manual. The handler is per-control; the step-level ordering in ApplyRunner is the backend chain. (5) LgpoRunnerTests.cs: test `ApplyPolicy_InvokesLgpoExe_WithCorrectArgs` (mock Process, verify args contain /m for Machine), `MissingLgpoExe_ThrowsFileNotFound`, `ExportPolicy_WritesOutputFile`. (6) ApplyConvergenceTests.cs: test `MaxReboots_Exceeded_ThrowsRebootException` (set RebootCount=3, attempt schedule, assert RebootException with "max_reboot_exceeded"), `ConvergenceStatus_Converged_WhenAllStepsComplete`, `ConvergenceStatus_Exceeded_WhenMaxReboots`, `RebootCount_IncrementedOnEachSchedule`. Use xUnit + FluentAssertions + NSubstitute following existing RebootCoordinatorTests pattern.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "LgpoRunner|ApplyConvergence"` — all tests pass. `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter RebootCoordinator` — existing tests still pass.</verify>
  <done>Max 3 reboots enforced with explicit abort. Post-reboot preflight re-runs before resuming. LGPO backend tested. Convergence status tracked on ApplyResult.</done>
</task>

</tasks>

<verification>
Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "LgpoRunner|ApplyConvergence|RebootCoordinator|ApplyRunner"` and confirm all tests pass. Build the full solution with `dotnet build` and confirm no regressions.
</verification>

<success_criteria>
APL-02 multi-backend apply is complete: DSC, LGPO, and Script backends are available with ordered fallback. Reboot convergence is tracked with max 3 limit. Post-reboot preflight validates system state before resuming. LGPO backend feels like DSC to the operator per CONTEXT.md.
</success_criteria>

<output>
After completion, create `.planning/phases/03-deterministic-mission-execution-core/03-04-SUMMARY.md`
</output>
