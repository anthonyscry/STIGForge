---
phase: 03-deterministic-mission-execution-core
plan: 05
type: execute
wave: 2
depends_on: [03-03]
files_modified:
  - src/STIGForge.Verify/VerifyOrchestrator.cs
  - src/STIGForge.Verify/NormalizedVerifyResult.cs
  - src/STIGForge.Verify/Adapters/ScapResultAdapter.cs
  - src/STIGForge.Verify/Adapters/EvaluateStigAdapter.cs
  - src/STIGForge.Verify/Adapters/CklAdapter.cs
  - tests/STIGForge.UnitTests/Verify/VerifyOrchestratorMappingTests.cs
autonomous: true
requirements:
  - VER-01
must_haves:
  truths:
    - "Verification adapters include raw artifact paths in NormalizedVerifyResult for provenance"
    - "VerifyOrchestrator consumes ScapMappingManifest to associate verification results back to controls per-STIG"
    - "Each NormalizedVerifyResult includes BenchmarkId from the mapping manifest"
    - "Unmapped controls appear in the consolidated report with reason no_scap_mapping from the manifest"
    - "Existing merge precedence (Manual CKL > Latest timestamp > Fail status) is preserved"
  artifacts:
    - path: "src/STIGForge.Verify/NormalizedVerifyResult.cs"
      provides: "NormalizedVerifyResult with RawArtifactPath and BenchmarkId fields"
      contains: "RawArtifactPath, BenchmarkId"
    - path: "src/STIGForge.Verify/VerifyOrchestrator.cs"
      provides: "Orchestrator that consumes ScapMappingManifest for per-STIG result association"
      contains: "ScapMappingManifest, ApplyMappingManifest"
    - path: "tests/STIGForge.UnitTests/Verify/VerifyOrchestratorMappingTests.cs"
      provides: "Tests for SCAP mapping manifest consumption during verification"
      contains: "MappingManifest_AssociatesResultsPerStig, UnmappedControls_IncludeReason"
  key_links:
    - from: "src/STIGForge.Verify/VerifyOrchestrator.cs"
      to: "ScapMappingManifest"
      via: "constructor or method parameter"
      pattern: "ScapMappingManifest"
    - from: "src/STIGForge.Verify/Adapters/ScapResultAdapter.cs"
      to: "NormalizedVerifyResult.RawArtifactPath"
      via: "set during parsing"
      pattern: "RawArtifactPath.*=.*outputPath"
---

<objective>
Normalize verification outputs into canonical results with provenance back to raw tool artifacts and per-STIG SCAP mapping association.

Purpose: VER-01 requires verification wrappers to normalize SCAP/SCC and Evaluate-STIG outputs into a canonical result model with provenance retained. The existing VerifyOrchestrator merges results from multiple tools but does not carry raw artifact paths or consume the ScapMappingManifest (from plan 03-03) to associate results per-STIG. Per CONTEXT.md: "VerifyOrchestrator consumes ScapMappingManifest to associate verification results back to controls per-STIG" and existing merge logic (Manual CKL > Latest timestamp > Fail status) should be preserved.
Output: Extended NormalizedVerifyResult with provenance fields, updated adapters, VerifyOrchestrator with mapping manifest consumption, tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-deterministic-mission-execution-core/03-CONTEXT.md
@.planning/phases/03-deterministic-mission-execution-core/03-RESEARCH.md
@.planning/phases/03-deterministic-mission-execution-core/03-03-SUMMARY.md
@src/STIGForge.Verify/VerifyOrchestrator.cs
@src/STIGForge.Verify/NormalizedVerifyResult.cs
@src/STIGForge.Verify/Adapters/ScapResultAdapter.cs
@src/STIGForge.Verify/Adapters/IVerifyResultAdapter.cs
@src/STIGForge.Core/Models/ScapMappingManifest.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add provenance fields to NormalizedVerifyResult and update adapters</name>
  <files>src/STIGForge.Verify/NormalizedVerifyResult.cs, src/STIGForge.Verify/Adapters/ScapResultAdapter.cs, src/STIGForge.Verify/Adapters/EvaluateStigAdapter.cs, src/STIGForge.Verify/Adapters/CklAdapter.cs</files>
  <action>In NormalizedVerifyResult.cs, add two new properties: `string? RawArtifactPath { get; set; }` (path to the original tool output file this result was parsed from) and `string? BenchmarkId { get; set; }` (SCAP benchmark this result maps to, populated from ScapMappingManifest). In ScapResultAdapter.ParseResults, set `RawArtifactPath = outputPath` on the NormalizedVerifyReport (add this field to NormalizedVerifyReport too: `string? RawArtifactPath`), and on each NormalizedVerifyResult set `RawArtifactPath = sourcePath` (already assigned to SourceFile — keep both, SourceFile is the display path, RawArtifactPath is the full absolute path to the raw artifact). In EvaluateStigAdapter, similarly set RawArtifactPath on each result to the source file path. In CklAdapter, set RawArtifactPath to the CKL file path. Also add `string? RawArtifactPath` to NormalizedVerifyReport for report-level provenance. In VerifyOrchestrator.ReconcileResults, when merging metadata, include `raw_artifact_paths` key listing all distinct RawArtifactPath values from the conflicting results.</action>
  <verify>`dotnet build src/STIGForge.Verify/STIGForge.Verify.csproj` compiles cleanly. `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter VerifyAdapterParsing` — existing adapter tests still pass.</verify>
  <done>All three adapters set RawArtifactPath for provenance. NormalizedVerifyResult carries BenchmarkId field ready for population.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ScapMappingManifest into VerifyOrchestrator and add tests</name>
  <files>src/STIGForge.Verify/VerifyOrchestrator.cs, tests/STIGForge.UnitTests/Verify/VerifyOrchestratorMappingTests.cs</files>
  <action>In VerifyOrchestrator, add a method `void ApplyMappingManifest(ConsolidatedVerifyReport report, ScapMappingManifest? manifest)`. If manifest is null, return (no-op for backward compatibility). For each result in report.Results: look up the result's VulnId or RuleId in manifest.ControlMappings. If found and Method != Unmapped, set result.BenchmarkId = mapping.BenchmarkId. If found and Method == Unmapped, add "no_scap_mapping" to result.Metadata dictionary under key "mapping_status". If not found in manifest at all, add "not_in_manifest" to metadata. Also add an overload of `ParseAndMergeResults` that accepts an optional `ScapMappingManifest?` parameter and calls ApplyMappingManifest after merging. Preserve the existing parameterless behavior. In VerifyOrchestratorMappingTests.cs: (1) `MappingManifest_AssociatesResultsPerStig` — create a manifest with 3 BenchmarkOverlap mappings and a report with matching results. Call ApplyMappingManifest. Assert each result.BenchmarkId matches the manifest entry. (2) `UnmappedControls_IncludeNoScapMappingReason` — create a manifest with 2 Unmapped entries. Assert result.Metadata contains "mapping_status" = "no_scap_mapping". (3) `NullManifest_PreservesExistingBehavior` — call with null manifest. Assert no changes to results. (4) `ExistingMergePrecedence_PreservedWithMapping` — create conflicting results (CKL pass, SCAP fail), merge, apply manifest. Assert CKL still wins AND BenchmarkId is populated. Use xUnit + FluentAssertions following existing VerifyOrchestratorTests pattern.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "VerifyOrchestratorMapping|VerifyOrchestrator"` — all tests pass (new and existing).</verify>
  <done>VerifyOrchestrator consumes ScapMappingManifest to enrich results with BenchmarkId and mapping status. Existing merge precedence is unchanged. Unmapped controls are visible in the consolidated report.</done>
</task>

</tasks>

<verification>
Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "VerifyOrchestrator|VerifyAdapterParsing"` and confirm all tests pass (new and existing). Build the full solution with `dotnet build` and confirm no regressions.
</verification>

<success_criteria>
VER-01 verification normalization is complete: adapters preserve provenance via RawArtifactPath, VerifyOrchestrator enriches results from ScapMappingManifest, unmapped controls surface with explicit reasons, and existing merge precedence is preserved.
</success_criteria>

<output>
After completion, create `.planning/phases/03-deterministic-mission-execution-core/03-05-SUMMARY.md`
</output>
