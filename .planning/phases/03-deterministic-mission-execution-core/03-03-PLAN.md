---
phase: 03-deterministic-mission-execution-core
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Core/Services/CanonicalScapSelector.cs
  - src/STIGForge.Core/Models/ScapMappingManifest.cs
  - src/STIGForge.Build/BundleBuilder.cs
  - tests/STIGForge.UnitTests/Services/ScapMappingManifestTests.cs
autonomous: true
requirements:
  - MAP-01
must_haves:
  truths:
    - "Each STIG bundle gets exactly one SCAP benchmark association with no multi-benchmark fallback"
    - "ScapMappingManifest maps each VulnId/RuleId to exactly one SCAP benchmark+rule with mapping confidence and method"
    - "Unmapped controls surface with reason no_scap_mapping in the mapping manifest"
    - "ScapMappingManifest is frozen at build time and written to Manifest/ directory"
    - "Mapping methods are benchmark_overlap (primary), strict_tag_match (secondary), unmapped"
  artifacts:
    - path: "src/STIGForge.Core/Models/ScapMappingManifest.cs"
      provides: "ScapMappingManifest model and per-control mapping entry"
      contains: "ScapMappingManifest, ScapControlMapping, ScapMappingMethod"
    - path: "src/STIGForge.Core/Services/CanonicalScapSelector.cs"
      provides: "Extended selector that produces ScapMappingManifest"
      contains: "BuildMappingManifest"
    - path: "src/STIGForge.Build/BundleBuilder.cs"
      provides: "ScapMappingManifest written to Manifest/ at build time"
      contains: "scap_mapping_manifest.json"
    - path: "tests/STIGForge.UnitTests/Services/ScapMappingManifestTests.cs"
      provides: "Tests for mapping manifest generation and invariant enforcement"
      contains: "SingleBenchmarkPerStig, UnmappedControls_HaveNoScapMappingReason"
  key_links:
    - from: "src/STIGForge.Build/BundleBuilder.cs"
      to: "CanonicalScapSelector"
      via: "BuildMappingManifest call during BuildAsync"
      pattern: "BuildMappingManifest"
    - from: "src/STIGForge.Core/Services/CanonicalScapSelector.cs"
      to: "ScapMappingManifest"
      via: "returns frozen manifest"
      pattern: "ScapMappingManifest"
---

<objective>
Enforce strict per-STIG SCAP mapping invariants so each control maps to exactly one benchmark with no cross-STIG fallback.

Purpose: MAP-01 requires per-STIG SCAP mapping with benchmark-overlap priority and no broad cross-STIG fallback. The existing CanonicalScapSelector selects a winner per STIG but does not produce a per-control frozen mapping manifest. Per CONTEXT.md: "ScapMappingManifest is the cornerstone of MAP-01 — it must be written at build time and consumed at verify time." This plan creates the manifest model, extends the selector, and writes it during bundle build. Plan 05 (VER-01) will consume it at verify time.
Output: ScapMappingManifest model, extended CanonicalScapSelector, BundleBuilder integration, unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/03-deterministic-mission-execution-core/03-CONTEXT.md
@.planning/phases/03-deterministic-mission-execution-core/03-RESEARCH.md
@src/STIGForge.Core/Services/CanonicalScapSelector.cs
@src/STIGForge.Core/Models/ControlRecord.cs
@src/STIGForge.Build/BundleBuilder.cs
@src/STIGForge.Build/BundleModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScapMappingManifest model and extend CanonicalScapSelector</name>
  <files>src/STIGForge.Core/Models/ScapMappingManifest.cs, src/STIGForge.Core/Services/CanonicalScapSelector.cs</files>
  <action>Create ScapMappingManifest.cs in STIGForge.Core.Models with: (1) `ScapMappingMethod` enum: `BenchmarkOverlap`, `StrictTagMatch`, `Unmapped`. (2) `ScapControlMapping` class: `string VulnId`, `string RuleId`, `string? BenchmarkId`, `string? BenchmarkRuleRef`, `ScapMappingMethod Method`, `double Confidence` (0.0-1.0), `string? Reason`. (3) `ScapMappingManifest` class: `string StigPackId`, `string StigName`, `string? SelectedBenchmarkPackId`, `string? SelectedBenchmarkName`, `IReadOnlyList<string> SelectionReasons`, `IReadOnlyList<ScapControlMapping> ControlMappings`, `DateTimeOffset GeneratedAt`, `int UnmappedCount` (computed from ControlMappings). In CanonicalScapSelector, add method `ScapMappingManifest BuildMappingManifest(CanonicalScapSelectionInput input, IReadOnlyList<ControlRecord> controls)`. Implementation: (a) Call existing `Select(input)` to get the winner benchmark. (b) For each control, attempt to match VulnId/RuleId against the winner's benchmark IDs. If the control's ExternalIds.RuleId appears in the winner's BenchmarkIds set (after normalization), mark as BenchmarkOverlap. If not but a tag-based match exists (control.ExternalIds contains a matching identifier), mark as StrictTagMatch. Otherwise, mark as Unmapped with reason "no_scap_mapping". (c) Set Confidence: BenchmarkOverlap=1.0, StrictTagMatch=0.7, Unmapped=0.0. (d) Return frozen ScapMappingManifest with all mappings. If no winner was selected (no candidates), all controls are Unmapped.</action>
  <verify>`dotnet build src/STIGForge.Core/STIGForge.Core.csproj` compiles cleanly.</verify>
  <done>ScapMappingManifest model exists. CanonicalScapSelector.BuildMappingManifest produces per-control mappings with method and confidence.</done>
</task>

<task type="auto">
  <name>Task 2: Wire ScapMappingManifest into BundleBuilder and add tests</name>
  <files>src/STIGForge.Build/BundleBuilder.cs, src/STIGForge.Build/BundleModels.cs, tests/STIGForge.UnitTests/Services/ScapMappingManifestTests.cs</files>
  <action>In BundleBuilder, add `CanonicalScapSelector _scapSelector` as an optional constructor parameter (default null for backward compatibility). In BuildAsync, after writing the existing manifest files, if `_scapSelector != null` and `request.Pack.BenchmarkIds` is available: build a `CanonicalScapSelectionInput` from request.Pack, call `_scapSelector.BuildMappingManifest(input, request.Controls)`, serialize to `scap_mapping_manifest.json` in the Manifest/ directory with `JsonSerializerOptions { WriteIndented = true }`. Add `ScapMappingManifestPath` to BundleBuildResult. In BundleBuildRequest, add optional `IReadOnlyList<CanonicalScapCandidate>? ScapCandidates` for providing SCAP benchmark candidates. In ScapMappingManifestTests.cs: (1) `SingleBenchmarkPerStig_ProducesConsistentMapping` — create input with 2 candidates, 5 controls. Assert winner is selected, all controls have a mapping, no control maps to a different benchmark. (2) `UnmappedControls_HaveNoScapMappingReason` — create input with no candidates. Assert all controls are Unmapped with reason containing "no_scap_mapping". (3) `NoCrossStigFallback_EnforcedWhenWinnerSelected` — create input where some controls have RuleIds not in the winner benchmark. Assert those controls are marked StrictTagMatch or Unmapped, never mapped to a different benchmark. (4) `MappingConfidence_MatchesMethod` — assert BenchmarkOverlap=1.0, StrictTagMatch=0.7, Unmapped=0.0. Use xUnit + FluentAssertions following existing CanonicalScapSelectorTests pattern.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter ScapMappingManifest` — all tests pass.</verify>
  <done>ScapMappingManifest is written to Manifest/scap_mapping_manifest.json at build time. Per-STIG invariant is enforced: no control maps to a different STIG's benchmark. Unmapped controls have explicit reasons.</done>
</task>

</tasks>

<verification>
Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter ScapMappingManifest` and confirm all tests pass. Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter CanonicalScapSelector` to confirm existing tests still pass. Build solution with `dotnet build` and confirm no regressions.
</verification>

<success_criteria>
MAP-01 SCAP mapping contract is enforced: each STIG gets exactly one benchmark, per-control mappings use benchmark_overlap/strict_tag_match/unmapped methods, no broad cross-STIG fallback occurs. Manifest is frozen at build time for downstream verification consumption.
</success_criteria>

<output>
After completion, create `.planning/phases/03-deterministic-mission-execution-core/03-03-SUMMARY.md`
</output>
