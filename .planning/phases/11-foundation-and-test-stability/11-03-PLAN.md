---
phase: 11-foundation-and-test-stability
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Core/Errors/StigForgeException.cs
  - src/STIGForge.Core/Errors/ErrorCodes.cs
autonomous: true
requirements:
  - ERRX-03

must_haves:
  truths:
    - "All domain exceptions have a machine-readable ErrorCode property"
    - "Error codes follow a structured format (COMPONENT_NUMBER)"
    - "Error codes can be cataloged and searched programmatically"
  artifacts:
    - path: "src/STIGForge.Core/Errors/StigForgeException.cs"
      provides: "Base exception class with ErrorCode property"
      exports: ["StigForgeException"]
    - path: "src/STIGForge.Core/Errors/ErrorCodes.cs"
      provides: "Centralized error code constants"
      exports: ["ErrorCodes"]
  key_links:
    - from: "StigForgeException"
      to: "ErrorCode property"
      via: "public string ErrorCode { get; }"
      pattern: "public string ErrorCode"
    - from: "ErrorCodes"
      to: "const string fields"
      via: "public const string"
      pattern: "public const string.*=.*\"[A-Z]+_\\d+\""
---

<objective>
Create structured error code infrastructure for machine-readable exception cataloging.

Purpose: Error codes enable automated error cataloging, filtering, and search. They provide a stable identifier that does not change when error messages are improved.

Output: Base exception class with ErrorCode property, centralized error code constants file.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-foundation-and-test-stability/11-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StigForgeException base class</name>
  <files>src/STIGForge.Core/Errors/StigForgeException.cs</files>
  <action>
    Create an abstract base exception class that all STIGForge domain exceptions will inherit from. It must include a machine-readable ErrorCode property.

    Create directory `src/STIGForge.Core/Errors/` if it does not exist.

    Create file `src/STIGForge.Core/Errors/StigForgeException.cs`:
    ```csharp
    namespace STIGForge.Core.Errors;

    /// <summary>
    /// Base class for all STIGForge domain exceptions.
    /// Provides a machine-readable ErrorCode for cataloging and programmatic handling.
    /// </summary>
    public abstract class StigForgeException : Exception
    {
        /// <summary>
        /// Gets the machine-readable error code for this exception.
        /// Format: COMPONENT_NUMBER (e.g., "BUILD_001", "IMPORT_002").
        /// </summary>
        public string ErrorCode { get; }

        /// <summary>
        /// Gets the optional component that raised this exception.
        /// </summary>
        public string? Component { get; }

        /// <summary>
        /// Initializes a new instance of the StigForgeException class.
        /// </summary>
        /// <param name="errorCode">The machine-readable error code.</param>
        /// <param name="message">The human-readable error message.</param>
        /// <param name="innerException">The inner exception that caused this exception.</param>
        protected StigForgeException(string errorCode, string message, Exception? innerException = null)
            : base(message, innerException)
        {
            ErrorCode = errorCode ?? throw new ArgumentNullException(nameof(errorCode));
        }

        /// <summary>
        /// Initializes a new instance of the StigForgeException class with a component identifier.
        /// </summary>
        /// <param name="errorCode">The machine-readable error code.</param>
        /// <param name="component">The component that raised this exception.</param>
        /// <param name="message">The human-readable error message.</param>
        /// <param name="innerException">The inner exception that caused this exception.</param>
        protected StigForgeException(string errorCode, string component, string message, Exception? innerException = null)
            : this(errorCode, message, innerException)
        {
            Component = component;
        }

        /// <summary>
        /// Returns a string representation including the error code for logging.
        /// </summary>
        public override string ToString()
        {
            var componentPrefix = Component != null ? $"[{Component}] " : "";
            return $"{componentPrefix}[{ErrorCode}] {base.ToString()}";
        }
    }
    ```

    This follows RESEARCH.md Pattern 5. Use structured string codes (e.g., "BUILD_001") rather than numeric HRESULT-style - they are self-documenting and searchable.
  </action>
  <verify>
    ```bash
    dotnet build src/STIGForge.Core/STIGForge.Core.csproj
    ```
    Build must succeed with no errors.
  </verify>
  <done>
    StigForgeException abstract class exists with ErrorCode property, Component property, and ToString() that includes error code.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ErrorCodes constants</name>
  <files>src/STIGForge.Core/Errors/ErrorCodes.cs</files>
  <action>
    Create a static class with error code constants for the major STIGForge operations.

    Create file `src/STIGForge.Core/Errors/ErrorCodes.cs`:
    ```csharp
    namespace STIGForge.Core.Errors;

    /// <summary>
    /// Centralized error code constants for STIGForge.
    /// Format: {COMPONENT}_{NUMBER} where NUMBER is a unique 3-digit identifier per component.
    /// </summary>
    public static class ErrorCodes
    {
        // Build errors (BUILD_001 - BUILD_099)
        public const string BUILD_BUNDLE_FAILED = "BUILD_001";
        public const string BUILD_INVALID_PROFILE = "BUILD_002";
        public const string BUILD_NO_STIGS_SELECTED = "BUILD_003";

        // Import errors (IMPORT_001 - IMPORT_099)
        public const string IMPORT_PARSE_FAILED = "IMPORT_001";
        public const string IMPORT_VALIDATION_FAILED = "IMPORT_002";
        public const string IMPORT_DUPLICATE_DETECTED = "IMPORT_003";

        // Apply errors (APPLY_001 - APPLY_099)
        public const string APPLY_DSC_FAILED = "APPLY_001";
        public const string APPLY_REBOOT_REQUIRED = "APPLY_002";
        public const string APPLY_SNAPSHOT_FAILED = "APPLY_003";
        public const string APPLY_VALIDATION_FAILED = "APPLY_004";

        // Verify errors (VERIFY_001 - VERIFY_099)
        public const string VERIFY_SCAP_FAILED = "VERIFY_001";
        public const string VERIFY_TIMEOUT = "VERIFY_002";
        public const string VERIFY_RESULTS_NOT_FOUND = "VERIFY_003";

        // Export errors (EXPORT_001 - EXPORT_099)
        public const string EXPORT_EMASS_FAILED = "EXPORT_001";
        public const string EXPORT_CKL_FAILED = "EXPORT_002";
        public const string EXPORT_XCCDF_FAILED = "EXPORT_003";

        // Orchestration errors (ORCH_001 - ORCH_099)
        public const string ORCH_PHASE_FAILED = "ORCH_001";
        public const string ORCH_INTEGRITY_VIOLATION = "ORCH_002";
        public const string ORCH_DEPENDENCY_MISSING = "ORCH_003";

        // Configuration errors (CONFIG_001 - CONFIG_099)
        public const string CONFIG_PATH_NOT_FOUND = "CONFIG_001";
        public const string CONFIG_INVALID_SETTING = "CONFIG_002";

        // Evidence errors (EVIDENCE_001 - EVIDENCE_099)
        public const string EVIDENCE_WRITE_FAILED = "EVIDENCE_001";
        public const string EVIDENCE_HASH_MISMATCH = "EVIDENCE_002";
    }
    ```

    Use flat two-part format (COMPONENT_NUMBER) for simplicity as recommended in RESEARCH.md Open Questions. This can be extended to hierarchical format later if catalog needs grow.
  </action>
  <verify>
    ```bash
    dotnet build src/STIGForge.Core/STIGForge.Core.csproj
    ```
    Build must succeed with no errors.
  </verify>
  <done>
    ErrorCodes static class exists with constants for Build, Import, Apply, Verify, Export, Orchestration, Configuration, and Evidence categories.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create example domain exception</name>
  <files>src/STIGForge.Core/Errors/BundleBuildException.cs</files>
  <action>
    Create an example domain exception that inherits from StigForgeException to demonstrate the pattern.

    Create file `src/STIGForge.Core/Errors/BundleBuildException.cs`:
    ```csharp
    namespace STIGForge.Core.Errors;

    /// <summary>
    /// Exception thrown when bundle building fails.
    /// </summary>
    public sealed class BundleBuildException : StigForgeException
    {
        /// <summary>
        /// Initializes a new instance of the BundleBuildException class.
        /// </summary>
        /// <param name="errorCode">The specific error code (e.g., BUILD_001, BUILD_002).</param>
        /// <param name="message">The human-readable error message.</param>
        /// <param name="innerException">The inner exception that caused this failure.</param>
        public BundleBuildException(string errorCode, string message, Exception? innerException = null)
            : base(errorCode, "Build", message, innerException)
        {
        }

        /// <summary>
        /// Creates a BundleBuildException for general bundle failure.
        /// </summary>
        public static BundleBuildException BundleFailed(string message, Exception? innerException = null)
            => new(ErrorCodes.BUILD_BUNDLE_FAILED, message, innerException);

        /// <summary>
        /// Creates a BundleBuildException for invalid profile.
        /// </summary>
        public static BundleBuildException InvalidProfile(string profileName)
            => new(ErrorCodes.BUILD_INVALID_PROFILE, $"Invalid profile: {profileName}");

        /// <summary>
        /// Creates a BundleBuildException for no STIGs selected.
        /// </summary>
        public static BundleBuildException NoStigsSelected()
            => new(ErrorCodes.BUILD_NO_STIGS_SELECTED, "No STIGs were selected for the bundle");
    }
    ```

    This demonstrates the pattern: domain exceptions inherit from StigForgeException and provide factory methods using ErrorCodes constants. Do NOT create all domain exceptions in this plan - just this one example establishes the pattern.
  </action>
  <verify>
    ```bash
    dotnet build src/STIGForge.Core/STIGForge.Core.csproj
    ```
    Build must succeed with no errors.
  </verify>
  <done>
    BundleBuildException exists as an example domain exception with factory methods using ErrorCodes constants.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create unit tests for error infrastructure</name>
  <files>tests/STIGForge.UnitTests/Errors/StigForgeExceptionTests.cs</files>
  <action>
    Create unit tests to verify error code behavior and ToString() output.

    Create directory `tests/STIGForge.UnitTests/Errors/` if it does not exist.

    Create file `tests/STIGForge.UnitTests/Errors/StigForgeExceptionTests.cs`:
    ```csharp
    using FluentAssertions;
    using STIGForge.Core.Errors;
    using Xunit;

    namespace STIGForge.UnitTests.Errors;

    public class StigForgeExceptionTests
    {
        [Fact]
        public void StigForgeException_Should_Set_ErrorCode()
        {
            // Arrange & Act
            var exception = new TestException("TEST_001", "Test message");

            // Assert
            exception.ErrorCode.Should().Be("TEST_001");
            exception.Message.Should().Be("Test message");
        }

        [Fact]
        public void StigForgeException_Should_Set_Component()
        {
            // Arrange & Act
            var exception = new TestException("TEST_001", "TestComponent", "Test message");

            // Assert
            exception.Component.Should().Be("TestComponent");
        }

        [Fact]
        public void StigForgeException_ToString_Should_Include_ErrorCode()
        {
            // Arrange
            var exception = new TestException("TEST_001", "Test message");

            // Act
            var result = exception.ToString();

            // Assert
            result.Should().Contain("[TEST_001]");
        }

        [Fact]
        public void BundleBuildException_FactoryMethods_Should_Use_CorrectErrorCodes()
        {
            // Arrange & Act
            var bundleFailed = BundleBuildException.BundleFailed("Failed");
            var invalidProfile = BundleBuildException.InvalidProfile("BadProfile");
            var noStigs = BundleBuildException.NoStigsSelected();

            // Assert
            bundleFailed.ErrorCode.Should().Be(ErrorCodes.BUILD_BUNDLE_FAILED);
            invalidProfile.ErrorCode.Should().Be(ErrorCodes.BUILD_INVALID_PROFILE);
            noStigs.ErrorCode.Should().Be(ErrorCodes.BUILD_NO_STIGS_SELECTED);
        }

        [Fact]
        public void ErrorCodes_Should_Follow_Format_Pattern()
        {
            // All error codes should match COMPONENT_NUMBER pattern
            var codes = typeof(ErrorCodes)
                .GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
                .Where(f => f.IsLiteral && f.FieldType == typeof(string))
                .Select(f => (string)f.GetValue(null)!)
                .ToList();

            foreach (var code in codes)
            {
                code.Should().MatchRegex("^[A-Z]+_\\d{3}$", $"code '{code}' should match COMPONENT_NUMBER format");
            }
        }

        private sealed class TestException : StigForgeException
        {
            public TestException(string errorCode, string message)
                : base(errorCode, message)
            {
            }

            public TestException(string errorCode, string component, string message)
                : base(errorCode, component, message)
            {
            }
        }
    }
    ```
  </action>
  <verify>
    ```bash
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~StigForgeExceptionTests"
    ```
    All tests must pass.
  </verify>
  <done>
    StigForgeExceptionTests exist and pass, verifying error code property, component property, ToString format, and error code pattern validation.
  </done>
</task>

</tasks>

<verification>
1. Core project builds successfully
2. Error code unit tests pass
3. All error codes follow COMPONENT_NUMBER format
4. BundleBuildException demonstrates domain exception pattern
</verification>

<success_criteria>
- StigForgeException base class exists with ErrorCode and Component properties
- ErrorCodes class has constants for all major operation categories
- Error codes follow COMPONENT_NUMBER format (e.g., BUILD_001)
- BundleBuildException demonstrates domain exception inheritance pattern
- Unit tests verify error code property and ToString() output
</success_criteria>

<output>
After completion, create `.planning/phases/11-foundation-and-test-stability/11-03-SUMMARY.md`
</output>
