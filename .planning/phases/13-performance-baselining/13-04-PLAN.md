---
phase: 13-performance-baselining
plan: 04
type: execute
wave: 3
depends_on: [13-02, 13-03]
files_modified:
  - docs/performance/BASELINES.md
  - docs/performance/MEMORY_PROFILE.md
  - docs/performance/IO_BOTTLENECKS.md
  - benchmarks/STIGForge.Benchmarks/MemoryBenchmarks.cs
  - benchmarks/STIGForge.Benchmarks/Program.cs
  - src/STIGForge.Build/BundleOrchestrator.cs
  - src/STIGForge.App/App.xaml.cs
  - src/STIGForge.Cli/CliHostFactory.cs
autonomous: true
requirements: [OBSV-03, PERF-05, PERF-06]
user_setup:
  - service: dotnet-diagnostic-tools
    why: "Memory profiling and I/O analysis requires .NET diagnostic tools"
    env_vars: []
    dashboard_config:
      - task: "Install dotnet-gcdump and dotnet-counters (optional for deeper analysis)"
        location: "dotnet tool install -g dotnet-gcdump && dotnet tool install -g dotnet-counters"

must_haves:
  truths:
    - "Memory benchmarks can detect memory growth via GC-based delta measurement"
    - "Baseline documentation provides templates for startup, mission, and memory metrics"
    - "I/O bottlenecks are identified and documented for future optimization"
    - "PerformanceInstrumenter records real-world mission metrics during execution"
  artifacts:
    - path: "docs/performance/BASELINES.md"
      provides: "Startup and mission duration baseline templates"
    - path: "docs/performance/MEMORY_PROFILE.md"
      provides: "Memory characteristics and leak detection methodology"
    - path: "docs/performance/IO_BOTTLENECKS.md"
      provides: "I/O bottleneck analysis and profiling methodology"
    - path: "benchmarks/STIGForge.Benchmarks/MemoryBenchmarks.cs"
      provides: "Memory leak detection benchmarks"
      exports: ["MissionCycleMemory", "RepeatedRuleProcessing"]
    - path: "src/STIGForge.Build/BundleOrchestrator.cs"
      provides: "Performance metric recording during mission execution"
      contains: "PerformanceInstrumenter"
  key_links:
    - from: "BundleOrchestrator"
      to: "PerformanceInstrumenter"
      via: "dependency injection"
      pattern: "RecordMissionCompleted"
    - from: "MemoryBenchmarks"
      to: "dotnet-gcdump"
      via: "methodology documentation"
      pattern: "GC.Collect"
---

<objective>
Create memory profiling benchmarks, I/O bottleneck analysis, and document all performance baselines in a structured format for future reference and regression detection.

Purpose: Complete PERF-05 (memory profile with leak detection) and PERF-06 (I/O bottlenecks identified), and consolidate all baseline measurements into documented reference.
Output: Memory benchmarks, baseline documentation (BASELINES.md, MEMORY_PROFILE.md, IO_BOTTLENECKS.md), and integration of PerformanceInstrumenter into mission execution.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-performance-baselining/13-RESEARCH.md
@.planning/phases/13-performance-baselining/13-01-SUMMARY.md
@.planning/phases/13-performance-baselining/13-02-SUMMARY.md
@.planning/phases/13-performance-baselining/13-03-SUMMARY.md

# Research baseline documentation template
@.planning/phases/13-performance-baselining/13-RESEARCH.md (contains BASELINES.md template)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MemoryBenchmarks for leak detection</name>
  <files>
    benchmarks/STIGForge.Benchmarks/MemoryBenchmarks.cs
    benchmarks/STIGForge.Benchmarks/Program.cs
  </files>
  <action>
Create MemoryBenchmarks.cs for memory profiling and leak detection capability validation.

1. Create MemoryBenchmarks class with:
   - [MemoryDiagnoser] attribute (critical)
   - [SimpleJob(RuntimeMoniker.Net80, launchCount: 3, warmupCount: 3, iterationCount: 10)]

2. Benchmarks:
   - MissionCycleMemory: Execute a full mission cycle and verify memory returns to baseline
   - RepeatedRuleProcessing: Process same rules multiple times, check for memory growth
   - LargeObjectHeapUsage: Test LOH behavior with large STIG content

3. Memory leak detection approach:
   - Capture memory before operation
   - Execute operation
   - Force GC (GC.Collect(), GC.WaitForPendingFinalizers(), GC.Collect())
   - Capture memory after
   - Assert memory delta is within acceptable threshold

4. Document methodology in comments:
   - How to use dotnet-gcdump for deeper analysis
   - How to compare snapshots with PerfView
   - Expected memory characteristics (what's normal vs. leak)

5. Update Program.cs BenchmarkSwitcher to include MemoryBenchmarks

IMPORTANT: Memory leak detection in benchmarks is probabilistic - not all leaks are detectable in short benchmark runs. Document this limitation and recommend dotnet-gcdump for production profiling.
  </action>
  <verify>
    <command>dotnet build benchmarks/STIGForge.Benchmarks/STIGForge.Benchmarks.csproj -c Release</command>
    <expect>Build succeeds with no errors</expect>
  </verify>
  <done>MemoryBenchmarks compiles with memory leak detection methodology, GC-based delta measurement, and documentation</done>
</task>

<task type="auto">
  <name>Task 2: Create performance baseline documentation</name>
  <files>
    docs/performance/BASELINES.md
    docs/performance/MEMORY_PROFILE.md
    docs/performance/IO_BOTTLENECKS.md
  </files>
  <action>
Create structured documentation for performance baselines based on template from RESEARCH.md.

1. Create docs/performance/ directory

2. Create BASELINES.md with:
   - Document header: date, hardware placeholder, runtime version
   - Startup Time table: cold, warm, perceived (targets: <3s, <1s, <2s)
   - Mission Duration table: Build/Apply/Verify/Prove at 100/1K/10K scales
   - Status columns marked as "Pending" (actual measurements come from running benchmarks)
   - Methodology section explaining how to run benchmarks

3. Create MEMORY_PROFILE.md with:
   - Memory characteristics table: Idle, Peak (10K rules), Post-mission, LOH size
   - Leak detection methodology (how to use dotnet-gcdump)
   - Expected memory patterns (what's normal)
   - Warning signs of memory issues

4. Create IO_BOTTLENECKS.md with:
   - I/O characteristics table: XML parsing rate, SQLite writes, File reads
   - Known bottlenecks identified from architecture analysis:
     - XML parsing of large XCCDF files
     - SQLite transaction patterns during apply
     - File system contention during bundle creation
   - Profiling methodology (how to use dotnet-trace, PerfView)
   - Future optimization opportunities (documented but not implemented)

NOTE: This creates the documentation structure. Actual measurements are filled in when benchmarks are executed. The "Pending" status and placeholder values are intentional - this is the baseline template.
  </action>
  <verify>
    <command>ls -la docs/performance/BASELINES.md docs/performance/MEMORY_PROFILE.md docs/performance/IO_BOTTLENECKS.md</command>
    <expect>All three files exist</expect>
  </verify>
  <done>Three performance documentation files created in docs/performance/ with baseline templates and methodology descriptions</done>
</task>

<task type="auto">
  <name>Task 3: Wire PerformanceInstrumenter into BundleOrchestrator</name>
  <files>
    src/STIGForge.Build/BundleOrchestrator.cs
    src/STIGForge.App/App.xaml.cs
    src/STIGForge.Cli/CliHostFactory.cs
  </files>
  <action>
Integrate PerformanceInstrumenter into BundleOrchestrator to record mission metrics during execution.

1. Inject PerformanceInstrumenter into BundleOrchestrator constructor

2. In OrchestrateAsync method:
   - Record start time at beginning of method
   - After each phase completes, calculate phase duration
   - Call PerformanceInstrumenter.RecordMissionCompleted with:
     - missionType: phase name (Apply, Verify, Prove)
     - ruleCount: from bundle manifest
     - durationMs: calculated duration

3. Register PerformanceInstrumenter as singleton in:
   - src/STIGForge.App/App.xaml.cs
   - src/STIGForge.Cli/CliHostFactory.cs

4. Follow existing pattern from MissionTracingService integration (Phase 12-03)

This enables OBSV-03 by collecting actual performance metrics during real mission execution, complementing the synthetic benchmarks.
  </action>
  <verify>
    <command>dotnet build src/STIGForge.Build/STIGForge.Build.csproj</command>
    <expect>Build succeeds with no errors</expect>
  </verify>
  <done>PerformanceInstrumenter records mission metrics during BundleOrchestrator execution, registered in both CLI and WPF hosts</done>
</task>

</tasks>

<verification>
- MemoryBenchmarks.cs exists with memory leak detection methodology
- Three documentation files exist in docs/performance/
- PerformanceInstrumenter wired into BundleOrchestrator
- All projects compile successfully
- BenchmarkSwitcher includes MemoryBenchmarks
</verification>

<success_criteria>
- Memory benchmarks provide leak detection capability with GC-based validation
- Baseline documentation structure created with templates and methodology
- I/O bottlenecks identified from architecture analysis documented
- PerformanceInstrumenter collects real-world metrics during mission execution
- All PERF requirements (01-06) now have measurement infrastructure
</success_criteria>

<output>
After completion, create `.planning/phases/13-performance-baselining/13-04-SUMMARY.md`
</output>
