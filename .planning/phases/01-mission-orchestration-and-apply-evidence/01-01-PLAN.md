---
phase: 01-mission-orchestration-and-apply-evidence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Core/Models/MissionRun.cs
  - src/STIGForge.Core/Abstractions/Services.cs
  - src/STIGForge.Infrastructure/Storage/DbBootstrap.cs
  - src/STIGForge.Infrastructure/Storage/MissionRunRepository.cs
  - src/STIGForge.Cli/CliHostFactory.cs
  - src/STIGForge.App/App.xaml.cs
  - tests/STIGForge.UnitTests/Infrastructure/MissionRunRepositoryTests.cs
autonomous: true
requirements:
  - FLOW-01
  - FLOW-02
  - FLOW-03
must_haves:
  truths:
    - "Mission runs are persisted as explicit records, not inferred from logs"
    - "Timeline events are append-only and ordered deterministically per run"
    - "CLI and WPF can resolve the same mission-run store through DI"
  artifacts:
    - path: "src/STIGForge.Core/Models/MissionRun.cs"
      provides: "Canonical run and timeline event contracts"
      contains: "MissionRun, MissionTimelineEvent"
    - path: "src/STIGForge.Infrastructure/Storage/MissionRunRepository.cs"
      provides: "SQLite append/query persistence for mission runs and events"
      contains: "AppendEventAsync"
    - path: "src/STIGForge.Infrastructure/Storage/DbBootstrap.cs"
      provides: "Database schema for mission_runs and mission_timeline tables"
      contains: "CREATE TABLE IF NOT EXISTS mission_timeline"
  key_links:
    - from: "src/STIGForge.Cli/CliHostFactory.cs"
      to: "MissionRunRepository"
      via: "AddSingleton registration"
      pattern: "AddSingleton.*MissionRun"
    - from: "src/STIGForge.App/App.xaml.cs"
      to: "MissionRunRepository"
      via: "AddSingleton registration"
      pattern: "AddSingleton.*MissionRun"
---

<objective>
Establish the shared mission-run persistence contract that all orchestration, evidence, and timeline surfaces depend on.

Purpose: Create one canonical, deterministic source of run/timeline truth for FLOW-01/02/03.
Output: Mission run models, SQLite schema/repository, and DI wiring for CLI and WPF.
</objective>

<execution_context>
@/home/anthonyscry/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-mission-orchestration-and-apply-evidence/01-RESEARCH.md
@src/STIGForge.Infrastructure/Storage/DbBootstrap.cs
@src/STIGForge.Infrastructure/Storage/SqliteRepositories.cs
@src/STIGForge.Cli/CliHostFactory.cs
@src/STIGForge.App/App.xaml.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define canonical MissionRun and timeline contracts</name>
  <files>src/STIGForge.Core/Models/MissionRun.cs, src/STIGForge.Core/Abstractions/Services.cs</files>
  <action>Create mission-run domain types (`MissionRun`, `MissionTimelineEvent`, event status/type enums, evidence linkage references) with explicit run ID, sequence index, phase marker, timestamps, and deterministic serialization fields. Add repository interface(s) in core abstractions for append-only event writes and run/timeline queries; do not use log-text parsing or mutable in-place status blobs.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter MissionRun`</verify>
  <done>Contracts compile, expose required run/timeline fields, and can represent start/finish/failure/skip/retry events plus evidence references.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SQLite mission-run ledger with append-only semantics</name>
  <files>src/STIGForge.Infrastructure/Storage/DbBootstrap.cs, src/STIGForge.Infrastructure/Storage/MissionRunRepository.cs</files>
  <action>Add `mission_runs` and `mission_timeline` tables in `DbBootstrap` (stable keys, run_id+seq uniqueness, indexed lookup by run_id and created_at). Implement `MissionRunRepository` using `Microsoft.Data.Sqlite` + Dapper with small transactions for append operations, deterministic ordering by `seq`, and no update path for historical events. Include read APIs for latest run and timeline-by-run projections needed by CLI/WPF.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter MissionRunRepository`</verify>
  <done>Repository appends ordered events, rejects duplicate sequence writes per run, and returns deterministic timeline ordering across repeated reads.</done>
</task>

<task type="auto">
  <name>Task 3: Register mission-run repository in both host composition roots</name>
  <files>src/STIGForge.Cli/CliHostFactory.cs, src/STIGForge.App/App.xaml.cs, tests/STIGForge.UnitTests/Infrastructure/MissionRunRepositoryTests.cs</files>
  <action>Wire mission-run repository through CLI and WPF DI using the existing SQLite connection string factory. Add unit tests proving repository creation succeeds under `DbBootstrap.EnsureCreated` and that both host factories can resolve the new service without startup regression.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "MissionRunRepository|CliHostFactory|AppXamlContract"`</verify>
  <done>Both app surfaces resolve the mission-run store, and repository tests pass with append/query behavior validated.</done>
</task>

</tasks>

<verification>
Run `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "MissionRun|MissionRunRepository|CliHostFactory|AppXamlContract"` and confirm all new ledger tests pass.
</verification>

<success_criteria>
Mission run/timeline persistence exists as a first-class append-only contract with deterministic query behavior and shared CLI/WPF registration.
</success_criteria>

<output>
After completion, create `.planning/phases/01-mission-orchestration-and-apply-evidence/01-01-SUMMARY.md`
</output>
