---
phase: 08-canonical-model-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Core/Models/ControlRecord.cs
  - src/STIGForge.Content/Import/ContentPackImporter.cs
  - tests/STIGForge.UnitTests/Core/ControlRecordModelTests.cs
  - tests/STIGForge.UnitTests/Content/ContentPackImporterTests.cs
autonomous: true
requirements:
  - CORE-01
must_haves:
  truths:
    - "ControlRecord has SourcePackId as string defaulting to string.Empty"
    - "ContentPackImporter sets SourcePackId on each ControlRecord during import to the originating ContentPack.PackId"
    - "ControlRecords are immutable snapshots — SourcePackId is set at import time and never updated on pack changes"
    - "Existing controls stored as JSON blobs deserialize safely with SourcePackId defaulting to empty when absent"
  artifacts:
    - path: "src/STIGForge.Core/Models/ControlRecord.cs"
      provides: "ControlRecord with SourcePackId provenance field"
      contains: "SourcePackId"
    - path: "src/STIGForge.Content/Import/ContentPackImporter.cs"
      provides: "Import logic that populates SourcePackId from ContentPack.PackId"
      contains: "SourcePackId"
    - path: "tests/STIGForge.UnitTests/Core/ControlRecordModelTests.cs"
      provides: "Unit tests for ControlRecord SourcePackId defaults"
      contains: "SourcePackId_DefaultsToEmpty, SourcePackId_CanBeAssigned"
  key_links:
    - from: "src/STIGForge.Content/Import/ContentPackImporter.cs"
      to: "ControlRecord.SourcePackId"
      via: "Import sets SourcePackId = pack.PackId on each control"
      pattern: "SourcePackId"
---

<objective>
Add SourcePackId provenance field to ControlRecord and wire it in ContentPackImporter during import.

Purpose: CORE-01 requires canonical ControlRecord entries to have provenance links back to their originating ContentPack. Currently ControlRecord has ExternalIds (RuleId, VulnId, SrgId, BenchmarkId) but no field linking the control to its source pack. Per CONTEXT.md: SourcePackId is a simple string foreign key to ContentPack.PackId, defaults to string.Empty, no cascading behavior on pack updates.
Output: Enhanced ControlRecord with SourcePackId, import wiring in ContentPackImporter, unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/08-canonical-model-completion/08-CONTEXT.md
@.planning/phases/08-canonical-model-completion/08-RESEARCH.md
@src/STIGForge.Core/Models/ControlRecord.cs
@src/STIGForge.Content/Import/ContentPackImporter.cs
@tests/STIGForge.UnitTests/Content/ContentPackImporterTests.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SourcePackId to ControlRecord model</name>
  <files>src/STIGForge.Core/Models/ControlRecord.cs</files>
  <action>Add a new property to ControlRecord:

`public string SourcePackId { get; set; } = string.Empty;`

Place it after ControlId and before ExternalIds — provenance is a top-level identity concern. Add an XML doc comment:

```csharp
/// <summary>
/// Foreign key reference to the ContentPack.PackId this control was imported from.
/// Set at import time; immutable after initial ingestion.
/// </summary>
```

The string.Empty default ensures backward compatibility: existing JSON blobs that lack this field will deserialize with SourcePackId = "" rather than null.</action>
  <verify>`dotnet build src/STIGForge.Core/STIGForge.Core.csproj` compiles. Existing tests still pass: `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter ControlRecord`.</verify>
  <done>ControlRecord has SourcePackId provenance field with safe empty default.</done>
</task>

<task type="auto">
  <name>Task 2: Wire SourcePackId population in ContentPackImporter</name>
  <files>src/STIGForge.Content/Import/ContentPackImporter.cs</files>
  <action>In ContentPackImporter, locate the code path(s) where ControlRecord instances are created from parsed STIG/SCAP/GPO content. For each code path that creates a ControlRecord, add assignment:

```csharp
control.SourcePackId = pack.PackId;
```

This should be done at the point where controls are associated with their ContentPack, typically in or after the parse methods (e.g., after STIG XML parsing creates control records, or after GPO parsing, etc.). The key is that every ControlRecord saved via the repository has its SourcePackId set to the PackId of the ContentPack it was imported from.

If there are multiple import pathways (STIG ZIP, SCAP bundle, GPO, LGPO, ADMX), ensure SourcePackId is set in each pathway. The simplest approach is to set it in a single location after all controls are parsed but before they are saved — look for the collection point where controls are gathered for persistence.</action>
  <verify>`dotnet build src/STIGForge.Content/STIGForge.Content.csproj` compiles. `dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter ContentPackImporter` — existing tests pass. `dotnet test tests/STIGForge.IntegrationTests/STIGForge.IntegrationTests.csproj --filter RoundTrip` — existing round-trip tests pass.</verify>
  <done>ContentPackImporter sets SourcePackId on all ControlRecords during import across all import pathways.</done>
</task>

<task type="auto">
  <name>Task 3: Add ControlRecord model and importer provenance tests</name>
  <files>tests/STIGForge.UnitTests/Core/ControlRecordModelTests.cs, tests/STIGForge.UnitTests/Content/ContentPackImporterTests.cs</files>
  <action>Create ControlRecordModelTests.cs in tests/STIGForge.UnitTests/Core/ with xUnit tests:

1. `SourcePackId_DefaultsToEmpty` — new ControlRecord().SourcePackId == string.Empty.
2. `SourcePackId_CanBeAssigned` — set SourcePackId to "test-pack-001", verify value.
3. `ExternalIds_DefaultsToNewInstance` — existing behavior preserved.

In ContentPackImporterTests.cs, add a new test (or extend existing):

4. `Import_SetsSourcePackIdOnControls` — import a test pack, verify all resulting ControlRecords have SourcePackId matching the ContentPack.PackId. If existing test infrastructure already imports packs and produces controls, add assertions to verify SourcePackId is populated.

Follow existing test patterns.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter "ControlRecordModel|ContentPackImporter"` — all tests pass.</verify>
  <done>ControlRecord model tests verify defaults and assignment. Importer tests verify SourcePackId is populated during import.</done>
</task>

</tasks>

<verification>
- `dotnet build` passes for Core, Content, and UnitTests projects
- `dotnet test --filter "ControlRecordModel|ContentPackImporter|RoundTrip"` — all tests pass (new and existing)
- New ControlRecord instance has SourcePackId = string.Empty
- Imported ControlRecords have SourcePackId matching their ContentPack.PackId
- Existing JSON-serialized controls deserialize safely (SourcePackId defaults to empty)
</verification>

<success_criteria>
CORE-01 provenance gap is closed: ControlRecord has SourcePackId linking each control back to its originating ContentPack. Import sets it at ingestion time. Backward-compatible with existing data.
</success_criteria>

<output>
After completion, create `.planning/phases/08-canonical-model-completion/08-02-SUMMARY.md`
</output>
