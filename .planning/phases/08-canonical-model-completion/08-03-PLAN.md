---
phase: 08-canonical-model-completion
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Core/Models/VerificationResult.cs
  - src/STIGForge.Core/Models/EvidenceRecord.cs
  - src/STIGForge.Core/Models/ExportIndexEntry.cs
  - src/STIGForge.Core/Models/CanonicalContract.cs
  - tests/STIGForge.UnitTests/Core/CanonicalSchemaTests.cs
autonomous: true
requirements:
  - CORE-02
must_haves:
  truths:
    - "VerificationResult exists in STIGForge.Core.Models as a sealed class with SchemaVersion"
    - "EvidenceRecord exists in STIGForge.Core.Models as a sealed class with SchemaVersion"
    - "ExportIndexEntry exists in STIGForge.Core.Models as a sealed class with SchemaVersion"
    - "CanonicalContract.Version is bumped to 1.1.0"
    - "CanonicalContract has string constants for all canonical type names"
    - "Core.Models VerificationResult is leaner than STIGForge.Verify.NormalizedVerifyResult — contract-level fields only"
    - "Core.Models EvidenceRecord represents the canonical evidence contract, not the index-specific EvidenceIndexEntry shape"
  artifacts:
    - path: "src/STIGForge.Core/Models/VerificationResult.cs"
      provides: "Canonical verification result contract type"
      contains: "VerificationResult, ControlId, VulnId, RuleId, Status, Tool, VerifiedAt, BenchmarkId, SchemaVersion"
    - path: "src/STIGForge.Core/Models/EvidenceRecord.cs"
      provides: "Canonical evidence record contract type"
      contains: "EvidenceRecord, ControlId, RuleId, Type, Sha256, TimestampUtc, RunId, SchemaVersion"
    - path: "src/STIGForge.Core/Models/ExportIndexEntry.cs"
      provides: "Canonical export index entry contract type"
      contains: "ExportIndexEntry, FilePath, ArtifactType, Sha256, TimestampUtc, SchemaVersion"
    - path: "src/STIGForge.Core/Models/CanonicalContract.cs"
      provides: "Version bump and type name constants"
      contains: "1.1.0, ContentPackType, ControlRecordType, ProfileType, OverlayType, BundleManifestType, VerificationResultType, EvidenceRecordType, ExportIndexEntryType"
    - path: "tests/STIGForge.UnitTests/Core/CanonicalSchemaTests.cs"
      provides: "Tests verifying canonical schema types and versioning"
      contains: "VerificationResult_HasSchemaVersion, EvidenceRecord_HasSchemaVersion, ExportIndexEntry_HasSchemaVersion, CanonicalContract_Version_Is_1_1_0"
  key_links:
    - from: "src/STIGForge.Core/Models/VerificationResult.cs"
      to: "CanonicalContract"
      via: "SchemaVersion = CanonicalContract.Version"
      pattern: "CanonicalContract.Version"
    - from: "src/STIGForge.Core/Models/EvidenceRecord.cs"
      to: "CanonicalContract"
      via: "SchemaVersion = CanonicalContract.Version"
      pattern: "CanonicalContract.Version"
    - from: "src/STIGForge.Core/Models/ExportIndexEntry.cs"
      to: "CanonicalContract"
      via: "SchemaVersion = CanonicalContract.Version"
      pattern: "CanonicalContract.Version"
---

<objective>
Create VerificationResult, EvidenceRecord, and ExportIndexEntry canonical schema types in Core.Models and update CanonicalContract with type constants and version bump.

Purpose: CORE-02 requires versioned, published schemas for ContentPack, ControlRecord, Profile, Overlay, BundleManifest, VerificationResult, EvidenceRecord, and ExportIndexEntry. The first five already exist. The last three are missing from the canonical Core.Models layer. Per CONTEXT.md: Core versions are the contract types (lean, cross-module communication); implementation modules keep their own richer types. CanonicalContract should bump to "1.1.0" since the schema is changing.
Output: Three new canonical model types in Core.Models, updated CanonicalContract, unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/08-canonical-model-completion/08-CONTEXT.md
@.planning/phases/08-canonical-model-completion/08-RESEARCH.md
@src/STIGForge.Core/Models/CanonicalContract.cs
@src/STIGForge.Core/Models/ContentPack.cs
@src/STIGForge.Core/Models/ControlRecord.cs
@src/STIGForge.Verify/NormalizedVerifyResult.cs
@src/STIGForge.Evidence/EvidenceModels.cs
@src/STIGForge.Evidence/EvidenceIndexModels.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VerificationResult canonical model</name>
  <files>src/STIGForge.Core/Models/VerificationResult.cs</files>
  <action>Create VerificationResult.cs in src/STIGForge.Core/Models/ as a sealed class. This is the canonical contract type — leaner than NormalizedVerifyResult in STIGForge.Verify.

```csharp
namespace STIGForge.Core.Models;

/// <summary>
/// Canonical verification result contract. Defines the cross-module schema for
/// verification outcomes. Implementation modules (STIGForge.Verify) retain
/// their own richer types; this type represents the published contract.
/// </summary>
public sealed class VerificationResult
{
    /// <summary>Control identifier (VulnId preferred, fallback to RuleId)</summary>
    public string ControlId { get; set; } = string.Empty;

    /// <summary>VulnId if available</summary>
    public string? VulnId { get; set; }

    /// <summary>RuleId if available</summary>
    public string? RuleId { get; set; }

    /// <summary>Verification status: Pass, Fail, NotApplicable, NotReviewed, Error</summary>
    public string Status { get; set; } = string.Empty;

    /// <summary>Tool that generated this result</summary>
    public string Tool { get; set; } = string.Empty;

    /// <summary>When this verification was performed</summary>
    public DateTimeOffset? VerifiedAt { get; set; }

    /// <summary>SCAP benchmark ID this result maps to</summary>
    public string? BenchmarkId { get; set; }

    /// <summary>Schema version for contract compatibility</summary>
    public string SchemaVersion { get; set; } = CanonicalContract.Version;
}
```

Note: Status is `string` (not an enum) at the contract level to avoid coupling Core to the Verify module's VerifyStatus enum. Consumer modules map to/from their own enums.</action>
  <verify>`dotnet build src/STIGForge.Core/STIGForge.Core.csproj` compiles.</verify>
  <done>VerificationResult canonical contract type exists in Core.Models with contract-level fields and SchemaVersion.</done>
</task>

<task type="auto">
  <name>Task 2: Create EvidenceRecord canonical model</name>
  <files>src/STIGForge.Core/Models/EvidenceRecord.cs</files>
  <action>Create EvidenceRecord.cs in src/STIGForge.Core/Models/ as a sealed class. This represents the canonical evidence contract — not the index-specific EvidenceIndexEntry shape from STIGForge.Evidence.

```csharp
namespace STIGForge.Core.Models;

/// <summary>
/// Canonical evidence record contract. Defines the cross-module schema for
/// evidence artifacts. Implementation modules (STIGForge.Evidence) retain
/// their own richer types; this type represents the published contract.
/// </summary>
public sealed class EvidenceRecord
{
    /// <summary>Control identifier this evidence supports</summary>
    public string ControlId { get; set; } = string.Empty;

    /// <summary>RuleId if available</summary>
    public string? RuleId { get; set; }

    /// <summary>Evidence artifact type (Command, File, Registry, PolicyExport, Screenshot, Other)</summary>
    public string Type { get; set; } = string.Empty;

    /// <summary>SHA-256 hash of the evidence artifact</summary>
    public string Sha256 { get; set; } = string.Empty;

    /// <summary>UTC timestamp when evidence was collected</summary>
    public string TimestampUtc { get; set; } = string.Empty;

    /// <summary>Run ID for apply-run provenance linkage</summary>
    public string? RunId { get; set; }

    /// <summary>Schema version for contract compatibility</summary>
    public string SchemaVersion { get; set; } = CanonicalContract.Version;
}
```</action>
  <verify>`dotnet build src/STIGForge.Core/STIGForge.Core.csproj` compiles.</verify>
  <done>EvidenceRecord canonical contract type exists in Core.Models with evidence-level fields and SchemaVersion.</done>
</task>

<task type="auto">
  <name>Task 3: Create ExportIndexEntry canonical model</name>
  <files>src/STIGForge.Core/Models/ExportIndexEntry.cs</files>
  <action>Create ExportIndexEntry.cs in src/STIGForge.Core/Models/ as a sealed class. This is a new type — no existing type to mirror.

```csharp
namespace STIGForge.Core.Models;

/// <summary>
/// Canonical export index entry contract. Represents a single file entry
/// in an export package index (e.g., eMASS package manifest).
/// </summary>
public sealed class ExportIndexEntry
{
    /// <summary>Relative file path within the export package</summary>
    public string FilePath { get; set; } = string.Empty;

    /// <summary>Artifact type classification (e.g., CKL, POA&M, Attestation, Evidence, Manifest)</summary>
    public string ArtifactType { get; set; } = string.Empty;

    /// <summary>SHA-256 hash of the file</summary>
    public string Sha256 { get; set; } = string.Empty;

    /// <summary>UTC timestamp when the file was written</summary>
    public string TimestampUtc { get; set; } = string.Empty;

    /// <summary>Schema version for contract compatibility</summary>
    public string SchemaVersion { get; set; } = CanonicalContract.Version;
}
```</action>
  <verify>`dotnet build src/STIGForge.Core/STIGForge.Core.csproj` compiles.</verify>
  <done>ExportIndexEntry canonical contract type exists in Core.Models with file-level fields and SchemaVersion.</done>
</task>

<task type="auto">
  <name>Task 4: Update CanonicalContract with version bump and type name constants</name>
  <files>src/STIGForge.Core/Models/CanonicalContract.cs</files>
  <action>Update CanonicalContract.cs:

1. Bump Version from "1.0.0" to "1.1.0" — schema is changing with new types and fields
2. Add string constants for all canonical type names for documentation and cross-module reference:

```csharp
public static class CanonicalContract
{
    public const string Version = "1.1.0";

    // Canonical type names for schema registry documentation
    public const string ContentPackType = "ContentPack";
    public const string ControlRecordType = "ControlRecord";
    public const string ProfileType = "Profile";
    public const string OverlayType = "Overlay";
    public const string BundleManifestType = "BundleManifest";
    public const string VerificationResultType = "VerificationResult";
    public const string EvidenceRecordType = "EvidenceRecord";
    public const string ExportIndexEntryType = "ExportIndexEntry";
}
```</action>
  <verify>`dotnet build src/STIGForge.Core/STIGForge.Core.csproj` compiles. Full solution `dotnet build` passes (verify no downstream breakage from version change).</verify>
  <done>CanonicalContract version bumped to 1.1.0 with type name constants for all eight canonical schema types.</done>
</task>

<task type="auto">
  <name>Task 5: Add canonical schema tests</name>
  <files>tests/STIGForge.UnitTests/Core/CanonicalSchemaTests.cs</files>
  <action>Create CanonicalSchemaTests.cs in tests/STIGForge.UnitTests/Core/ with xUnit tests:

1. `CanonicalContract_Version_Is_1_1_0` — CanonicalContract.Version == "1.1.0".
2. `CanonicalContract_HasAllTypeConstants` — verify all 8 type name constants are non-empty strings.
3. `VerificationResult_HasSchemaVersion` — new VerificationResult().SchemaVersion == CanonicalContract.Version.
4. `VerificationResult_DefaultsAreSafe` — ControlId is string.Empty, Status is string.Empty, VulnId is null.
5. `EvidenceRecord_HasSchemaVersion` — new EvidenceRecord().SchemaVersion == CanonicalContract.Version.
6. `EvidenceRecord_DefaultsAreSafe` — ControlId is string.Empty, Sha256 is string.Empty, RunId is null.
7. `ExportIndexEntry_HasSchemaVersion` — new ExportIndexEntry().SchemaVersion == CanonicalContract.Version.
8. `ExportIndexEntry_DefaultsAreSafe` — FilePath is string.Empty, ArtifactType is string.Empty, Sha256 is string.Empty.
9. `ContentPack_SchemaVersion_MatchesCanonical` — new ContentPack().SchemaVersion == CanonicalContract.Version.

Follow existing test patterns.</action>
  <verify>`dotnet test tests/STIGForge.UnitTests/STIGForge.UnitTests.csproj --filter CanonicalSchema` — all tests pass.</verify>
  <done>Canonical schema tests verify all three new types have correct SchemaVersion, safe defaults, and CanonicalContract has correct version and constants.</done>
</task>

</tasks>

<verification>
- `dotnet build` passes for Core and UnitTests projects
- Full solution `dotnet build` passes (no downstream breakage from version bump)
- `dotnet test --filter "CanonicalSchema"` — all tests pass
- VerificationResult, EvidenceRecord, ExportIndexEntry exist in STIGForge.Core.Models namespace
- CanonicalContract.Version is "1.1.0" with all 8 type constants
- New types are leaner than their implementation counterparts (Verify/Evidence modules)
</verification>

<success_criteria>
CORE-02 schema gap is closed: All eight canonical schema types (ContentPack, ControlRecord, Profile, Overlay, BundleManifest, VerificationResult, EvidenceRecord, ExportIndexEntry) are versioned and published from the Core.Models layer.
</success_criteria>

<output>
After completion, create `.planning/phases/08-canonical-model-completion/08-03-SUMMARY.md`
</output>
