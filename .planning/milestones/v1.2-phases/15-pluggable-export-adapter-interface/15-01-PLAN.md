---
phase: 15-pluggable-export-adapter-interface
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Export/ExportModels.cs
  - src/STIGForge.Export/ExportAdapterRegistry.cs
  - src/STIGForge.Export/ExportOrchestrator.cs
  - src/STIGForge.Export/EmassExporter.cs
  - src/STIGForge.Export/CklExportAdapter.cs
  - tests/STIGForge.UnitTests/Export/ExportAdapterRegistryTests.cs
  - tests/STIGForge.UnitTests/Export/ExportOrchestratorTests.cs
  - tests/STIGForge.UnitTests/Export/CklExportAdapterTests.cs
  - tests/STIGForge.UnitTests/Export/EmassExportAdapterTests.cs
autonomous: true
requirements:
  - EXP-04
  - EXP-05

must_haves:
  truths:
    - "ExportAdapterRegistry resolves a registered adapter by case-insensitive format name"
    - "ExportAdapterRegistry returns null for an unregistered format name"
    - "ExportOrchestrator dispatches to the correct adapter and returns its result"
    - "ExportOrchestrator returns Success=false with error message for unknown format"
    - "EmassExporter implements IExportAdapter and its adapter method delegates to the existing ExportAsync"
    - "CklExportAdapter implements IExportAdapter and delegates to CklExporter.ExportCkl static method"
    - "Existing CklExporter.ExportCkl static call sites compile and work unchanged"
    - "Existing EmassExporter.ExportAsync(ExportRequest, ct) call sites compile and work unchanged"
  artifacts:
    - path: "src/STIGForge.Export/ExportModels.cs"
      provides: "IExportAdapter interface, ExportAdapterRequest, ExportAdapterResult"
      contains: "interface IExportAdapter"
    - path: "src/STIGForge.Export/ExportAdapterRegistry.cs"
      provides: "Format-name-to-adapter resolution"
      exports: ["ExportAdapterRegistry"]
    - path: "src/STIGForge.Export/ExportOrchestrator.cs"
      provides: "Dispatches export by format name through registry"
      exports: ["ExportOrchestrator"]
    - path: "src/STIGForge.Export/CklExportAdapter.cs"
      provides: "IExportAdapter wrapper for static CklExporter"
      exports: ["CklExportAdapter"]
    - path: "src/STIGForge.Export/EmassExporter.cs"
      provides: "IExportAdapter implementation on existing EmassExporter class"
      contains: "IExportAdapter"
  key_links:
    - from: "src/STIGForge.Export/ExportOrchestrator.cs"
      to: "src/STIGForge.Export/ExportAdapterRegistry.cs"
      via: "constructor injection"
      pattern: "ExportAdapterRegistry"
    - from: "src/STIGForge.Export/CklExportAdapter.cs"
      to: "src/STIGForge.Export/CklExporter.cs"
      via: "static delegation"
      pattern: "CklExporter\\.ExportCkl"
    - from: "src/STIGForge.Export/EmassExporter.cs"
      to: "src/STIGForge.Export/ExportModels.cs"
      via: "interface implementation"
      pattern: "IExportAdapter\\.ExportAsync"
---

<objective>
Define the `IExportAdapter` contract, `ExportAdapterRegistry`, and `ExportOrchestrator` in `STIGForge.Export`, then retrofit `EmassExporter` and `CklExporter` to implement the interface using TDD.

Purpose: Establish the pluggable export architecture that Phases 16-19 depend on. Every future export format (XCCDF, CSV, Excel) will implement `IExportAdapter` and register with the registry. Existing call sites must not break.

Output: Interface, request/result models, registry, orchestrator, two adapter implementations, and comprehensive tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-pluggable-export-adapter-interface/15-RESEARCH.md
@src/STIGForge.Export/ExportModels.cs
@src/STIGForge.Export/EmassExporter.cs
@src/STIGForge.Export/CklExporter.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define IExportAdapter, models, registry, and orchestrator with tests (RED then GREEN)</name>
  <files>
    src/STIGForge.Export/ExportModels.cs
    src/STIGForge.Export/ExportAdapterRegistry.cs
    src/STIGForge.Export/ExportOrchestrator.cs
    tests/STIGForge.UnitTests/Export/ExportAdapterRegistryTests.cs
    tests/STIGForge.UnitTests/Export/ExportOrchestratorTests.cs
  </files>
  <action>
    **Step 1 — Add interface and models to ExportModels.cs:**

    Append the following types to the existing `STIGForge.Export` namespace in `ExportModels.cs` (do NOT modify existing classes):

    ```csharp
    public interface IExportAdapter
    {
        string FormatName { get; }
        string[] SupportedExtensions { get; }
        Task<ExportAdapterResult> ExportAsync(ExportAdapterRequest request, CancellationToken ct);
    }

    public sealed class ExportAdapterRequest
    {
        public string BundleRoot { get; set; } = string.Empty;
        public IReadOnlyList<ControlResult> Results { get; set; } = Array.Empty<ControlResult>();
        public string OutputDirectory { get; set; } = string.Empty;
        public string? FileNameStem { get; set; }
        public IReadOnlyDictionary<string, string> Options { get; set; }
            = new Dictionary<string, string>();
    }

    public sealed class ExportAdapterResult
    {
        public bool Success { get; set; }
        public IReadOnlyList<string> OutputPaths { get; set; } = Array.Empty<string>();
        public IReadOnlyList<string> Warnings { get; set; } = Array.Empty<string>();
        public string? ErrorMessage { get; set; }
    }
    ```

    Add `using STIGForge.Verify;` at the top of `ExportModels.cs` if not already present (needed for `ControlResult`).

    **Step 2 — Create ExportAdapterRegistry.cs:**

    New file `src/STIGForge.Export/ExportAdapterRegistry.cs`:
    - `Register(IExportAdapter adapter)` — throws `ArgumentNullException` on null
    - `TryResolve(string formatName)` — case-insensitive `StringComparison.OrdinalIgnoreCase` lookup via LINQ `FirstOrDefault`; returns `null` if not found
    - `GetAll()` — returns `_adapters.AsReadOnly()`

    **Step 3 — Create ExportOrchestrator.cs:**

    New file `src/STIGForge.Export/ExportOrchestrator.cs`:
    - Constructor takes `ExportAdapterRegistry`, throws `ArgumentNullException` on null
    - `ExportAsync(string formatName, ExportAdapterRequest request, CancellationToken ct)`:
      - Calls `_registry.TryResolve(formatName)`
      - If null, returns `ExportAdapterResult { Success = false, ErrorMessage = "No export adapter registered for format '{formatName}'." }`
      - Otherwise, delegates to `adapter.ExportAsync(request, ct)`

    **Step 4 — Write tests (RED phase):**

    Create `tests/STIGForge.UnitTests/Export/ExportAdapterRegistryTests.cs`:
    - `Register_NullAdapter_ThrowsArgumentNullException`
    - `TryResolve_RegisteredFormat_ReturnsAdapter` — register a stub adapter with FormatName="Test", resolve "test" (case-insensitive), assert not null
    - `TryResolve_UnknownFormat_ReturnsNull`
    - `GetAll_ReturnsAllRegistered` — register 2 stubs, assert count == 2

    Create `tests/STIGForge.UnitTests/Export/ExportOrchestratorTests.cs`:
    - `ExportAsync_KnownFormat_DelegatesToAdapter` — register stub, call orchestrator, assert stub was invoked
    - `ExportAsync_UnknownFormat_ReturnsFailureResult` — call with unregistered format, assert `Success == false` and `ErrorMessage` contains format name

    Use a private `StubExportAdapter : IExportAdapter` in the test files for isolation. The stub returns a canned `ExportAdapterResult { Success = true, OutputPaths = new[] { "/fake/path" } }`.

    **Step 5 — Run tests, confirm GREEN:**

    ```bash
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~ExportAdapterRegistry|FullyQualifiedName~ExportOrchestrator" --no-restore
    ```

    All tests must pass. Existing export tests must also still pass:
    ```bash
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~Export" --no-restore
    ```
  </action>
  <verify>
    ```bash
    dotnet build src/STIGForge.Export/STIGForge.Export.csproj --no-restore
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~ExportAdapterRegistry|FullyQualifiedName~ExportOrchestrator" --no-restore
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~Export" --no-restore
    ```
    All commands exit 0. No existing test regressions.
  </verify>
  <done>
    IExportAdapter interface exists in ExportModels.cs with ExportAdapterRequest and ExportAdapterResult. ExportAdapterRegistry resolves adapters by case-insensitive format name. ExportOrchestrator dispatches to the correct adapter or returns fail-closed result. 6 registry/orchestrator tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Retrofit EmassExporter and create CklExportAdapter with tests (RED then GREEN)</name>
  <files>
    src/STIGForge.Export/EmassExporter.cs
    src/STIGForge.Export/CklExportAdapter.cs
    tests/STIGForge.UnitTests/Export/EmassExportAdapterTests.cs
    tests/STIGForge.UnitTests/Export/CklExportAdapterTests.cs
  </files>
  <action>
    **Step 1 — Add IExportAdapter to EmassExporter:**

    In `EmassExporter.cs`, change the class declaration to:
    ```csharp
    public sealed class EmassExporter : IExportAdapter
    ```

    Add the following members to `EmassExporter`:
    ```csharp
    // IExportAdapter members
    public string FormatName => "eMASS";
    public string[] SupportedExtensions => Array.Empty<string>(); // produces directory, not single file

    // Explicit interface implementation avoids overload confusion with existing ExportAsync(ExportRequest, ct)
    async Task<ExportAdapterResult> IExportAdapter.ExportAsync(
        ExportAdapterRequest request, CancellationToken ct)
    {
        try
        {
            var result = await ExportAsync(new ExportRequest
            {
                BundleRoot = request.BundleRoot,
                OutputRoot = string.IsNullOrWhiteSpace(request.OutputDirectory)
                    ? null : request.OutputDirectory
            }, ct).ConfigureAwait(false);

            return new ExportAdapterResult
            {
                Success = result.IsReadyForSubmission,
                OutputPaths = new[] { result.OutputRoot },
                Warnings = result.Warnings,
                ErrorMessage = result.BlockingFailures.Count > 0
                    ? string.Join("; ", result.BlockingFailures) : null
            };
        }
        catch (Exception ex)
            when (ex is ArgumentException or DirectoryNotFoundException or FileNotFoundException or IOException)
        {
            return new ExportAdapterResult { Success = false, ErrorMessage = ex.Message };
        }
    }
    ```

    Use explicit interface implementation (`Task<ExportAdapterResult> IExportAdapter.ExportAsync(...)`) so the method is only visible through an `IExportAdapter` reference. The existing `ExportAsync(ExportRequest, ct)` overload remains the primary call for existing callers.

    **Step 2 — Create CklExportAdapter.cs:**

    New file `src/STIGForge.Export/CklExportAdapter.cs`. This is a separate wrapper class because `CklExporter` is `static` and static classes cannot implement interfaces in C#.

    ```csharp
    namespace STIGForge.Export;

    public sealed class CklExportAdapter : IExportAdapter
    {
        public string FormatName => "CKL";
        public string[] SupportedExtensions => new[] { ".ckl", ".cklb" };

        public Task<ExportAdapterResult> ExportAsync(
            ExportAdapterRequest request, CancellationToken ct)
        {
            if (string.IsNullOrWhiteSpace(request.BundleRoot))
                return Task.FromResult(new ExportAdapterResult
                {
                    Success = false,
                    ErrorMessage = "BundleRoot is required for CKL export."
                });

            request.Options.TryGetValue("format", out var fmtStr);
            var format = string.Equals(fmtStr, "cklb", StringComparison.OrdinalIgnoreCase)
                ? CklFileFormat.Cklb : CklFileFormat.Ckl;

            request.Options.TryGetValue("include-csv", out var csvStr);
            var includeCsv = string.Equals(csvStr, "true", StringComparison.OrdinalIgnoreCase);

            var result = CklExporter.ExportCkl(new CklExportRequest
            {
                BundleRoot = request.BundleRoot,
                OutputDirectory = string.IsNullOrWhiteSpace(request.OutputDirectory)
                    ? null : request.OutputDirectory,
                FileName = request.FileNameStem,
                FileFormat = format,
                IncludeCsv = includeCsv
            });

            return Task.FromResult(new ExportAdapterResult
            {
                Success = true,
                OutputPaths = result.OutputPaths.ToArray(),
                Warnings = result.ControlCount == 0
                    ? new[] { result.Message } : Array.Empty<string>()
            });
        }
    }
    ```

    Key design decisions:
    - `CklExportAdapter` wraps static `CklExporter` — existing `CklExporter.ExportCkl(...)` static call sites are unchanged.
    - `Success = true` on the no-exception path even if `ControlCount == 0` (empty export is valid). Surface the message as a warning.
    - `BundleRoot` validation up front (CKL always reads from disk).

    **Step 3 — Write tests (RED phase):**

    Create `tests/STIGForge.UnitTests/Export/EmassExportAdapterTests.cs`:
    - `FormatName_ReturnsEmass` — assert `FormatName == "eMASS"`
    - `SupportedExtensions_ReturnsEmpty` — assert empty array (directory output)
    - `ImplementsIExportAdapter` — assert `typeof(IExportAdapter).IsAssignableFrom(typeof(EmassExporter))`

    Create `tests/STIGForge.UnitTests/Export/CklExportAdapterTests.cs`:
    - `FormatName_ReturnsCKL` — assert `FormatName == "CKL"`
    - `SupportedExtensions_ContainsCklAndCklb` — assert contains ".ckl" and ".cklb"
    - `ImplementsIExportAdapter` — assert `typeof(IExportAdapter).IsAssignableFrom(typeof(CklExportAdapter))`
    - `ExportAsync_EmptyBundleRoot_ReturnsFailure` — call with empty BundleRoot, assert `Success == false` and `ErrorMessage` contains "BundleRoot"

    Note: Full integration tests for the actual export are not in scope here. These adapter tests verify the interface contract and delegation wiring, not file I/O. Existing `CklExporterTests.cs` and `EmassExporterConsistencyTests.cs` cover the underlying export logic.

    **Step 4 — Run tests, confirm GREEN:**

    ```bash
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~ExportAdapter|FullyQualifiedName~EmassExportAdapter|FullyQualifiedName~CklExportAdapter" --no-restore
    ```

    Then run ALL export tests to confirm no regressions:
    ```bash
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~Export" --no-restore
    ```
  </action>
  <verify>
    ```bash
    dotnet build src/STIGForge.Export/STIGForge.Export.csproj --no-restore
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~ExportAdapter|FullyQualifiedName~EmassExportAdapter|FullyQualifiedName~CklExportAdapter" --no-restore
    dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~Export" --no-restore
    ```
    All commands exit 0. Existing CklExporter and EmassExporter tests still pass.
  </verify>
  <done>
    EmassExporter implements IExportAdapter via explicit interface implementation. CklExportAdapter wraps static CklExporter and implements IExportAdapter. All adapter contract tests pass. All existing export tests pass unchanged — no call site regressions.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/STIGForge.Export/STIGForge.Export.csproj` — compiles without errors on both net48 and net8.0 targets
2. `dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~Export"` — all export tests pass (new + existing)
3. `grep "IExportAdapter" src/STIGForge.Export/ExportModels.cs` — interface exists
4. `grep "IExportAdapter" src/STIGForge.Export/EmassExporter.cs` — EmassExporter implements it
5. `grep "IExportAdapter" src/STIGForge.Export/CklExportAdapter.cs` — CklExportAdapter implements it
6. `grep "CklExporter.ExportCkl" src/STIGForge.App/MainViewModel.Export.cs` — static call site unchanged
7. `grep "CklExporter.ExportCkl" src/STIGForge.Cli/Commands/ExportCommands.cs` — static call site unchanged
</verification>

<success_criteria>
- IExportAdapter interface exists with FormatName, SupportedExtensions, and ExportAsync members
- ExportAdapterRequest carries BundleRoot, Results, OutputDirectory, FileNameStem, and Options
- ExportAdapterResult carries Success, OutputPaths, Warnings, and ErrorMessage (not void)
- ExportAdapterRegistry resolves adapters by case-insensitive format name
- ExportOrchestrator dispatches to the correct adapter or returns fail-closed result
- EmassExporter implements IExportAdapter (explicit interface implementation)
- CklExportAdapter wraps CklExporter and implements IExportAdapter
- All existing call sites to CklExporter.ExportCkl and EmassExporter.ExportAsync compile unchanged
- All new and existing export tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-pluggable-export-adapter-interface/15-01-SUMMARY.md`
</output>
