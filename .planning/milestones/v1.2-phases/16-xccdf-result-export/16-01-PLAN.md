---
phase: 16-xccdf-result-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/STIGForge.Export/XccdfExportAdapter.cs
  - src/STIGForge.Cli/Commands/ExportCommands.cs
  - tests/STIGForge.UnitTests/Export/XccdfExportAdapterTests.cs
autonomous: true
requirements: [EXP-01]

must_haves:
  truths:
    - "Operator runs export-xccdf CLI command and receives a valid XCCDF 1.2 XML file"
    - "Every XML element in the output carries the http://checklists.nist.gov/xccdf/1.2 namespace"
    - "ScapResultAdapter.CanHandle() returns true for the exported file and ParseResults() recovers the same result count"
    - "If the adapter throws mid-export, no partial output file remains on disk"
  artifacts:
    - path: "src/STIGForge.Export/XccdfExportAdapter.cs"
      provides: "IExportAdapter implementation for XCCDF 1.2 XML export"
      contains: "class XccdfExportAdapter"
    - path: "tests/STIGForge.UnitTests/Export/XccdfExportAdapterTests.cs"
      provides: "Round-trip validation, namespace, fail-closed, and empty-results tests"
      contains: "class XccdfExportAdapterTests"
  key_links:
    - from: "src/STIGForge.Export/XccdfExportAdapter.cs"
      to: "src/STIGForge.Verify/Adapters/ScapResultAdapter.cs"
      via: "Round-trip contract: XccdfExportAdapter generates XML that ScapResultAdapter can parse"
      pattern: "XccdfNs.*checklists\\.nist\\.gov"
    - from: "src/STIGForge.Cli/Commands/ExportCommands.cs"
      to: "src/STIGForge.Export/XccdfExportAdapter.cs"
      via: "CLI export-xccdf command creates adapter and calls ExportAsync"
      pattern: "XccdfExportAdapter"
---

<objective>
Implement XccdfExportAdapter that exports verify results as XCCDF 1.2 XML and wire the export-xccdf CLI command.

Purpose: Operators need XCCDF 1.2 XML output for interoperability with Tenable, ACAS, STIG Viewer, and OpenRMF. This is the first format-specific adapter built on the Phase 15 IExportAdapter foundation.

Output: XccdfExportAdapter class, export-xccdf CLI command, unit tests with round-trip validation.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/STIGForge.Export/ExportModels.cs
@src/STIGForge.Export/CklExportAdapter.cs
@src/STIGForge.Export/ExportAdapterRegistry.cs
@src/STIGForge.Verify/Adapters/ScapResultAdapter.cs
@src/STIGForge.Verify/VerifyModels.cs
@src/STIGForge.Verify/VerifyReportReader.cs
@src/STIGForge.Cli/Commands/ExportCommands.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create XccdfExportAdapter with round-trip fidelity</name>
  <files>
    src/STIGForge.Export/XccdfExportAdapter.cs
    tests/STIGForge.UnitTests/Export/XccdfExportAdapterTests.cs
  </files>
  <action>
Create `src/STIGForge.Export/XccdfExportAdapter.cs` implementing `IExportAdapter`:

1. **Class structure:**
   - `FormatName => "XCCDF"`
   - `SupportedExtensions => new[] { ".xml" }`
   - `private static readonly XNamespace XccdfNs = "http://checklists.nist.gov/xccdf/1.2";`

2. **ExportAsync implementation:**
   - Determine output path: `Path.Combine(request.OutputDirectory, (request.FileNameStem ?? "stigforge_xccdf_results") + ".xml")`
   - Build XDocument with `Benchmark` root element in XccdfNs namespace
   - Add `TestResult` child element with `version="1.0"` attribute
   - Add `start-time` and `end-time` child elements. Use the earliest and latest `VerifiedAt` from request.Results, falling back to `DateTimeOffset.UtcNow` if no results. Format timestamps with `.ToString("o")` (ISO 8601 round-trip format).
   - For each `ControlResult` in `request.Results`, create a `rule-result` element:
     - `idref` attribute = `result.RuleId ?? result.VulnId ?? "unknown"`
     - `time` attribute = `result.VerifiedAt?.ToString("o")` (omit attribute if null)
     - `weight` attribute = map severity to weight: `"high" -> "10.0"`, `"medium" -> "5.0"`, `"low" -> "1.0"`, other/null -> omit attribute
     - `result` child element = map status to canonical XCCDF value: `"Pass"/"NotAFinding" -> "pass"`, `"Fail"/"Open" -> "fail"`, `"NotApplicable"/"NA" -> "notapplicable"`, `"NotReviewed"/"NotChecked" -> "notchecked"`, `"Informational" -> "informational"`, `"Error" -> "error"`, other -> `"unknown"`
     - `ident` child element with `system="http://cyber.mil/cci"` and text = `result.VulnId` (only if VulnId is non-null/non-empty)
     - `message` child element with text = `result.FindingDetails` (only if FindingDetails is non-null/non-empty)
   - **CRITICAL: Every XElement MUST use `XccdfNs + "elementName"` — never bare string element names**

3. **Fail-closed write pattern:**
   - Create output directory if it doesn't exist: `Directory.CreateDirectory(request.OutputDirectory)`
   - Write to temp file (`outputPath + ".tmp"`)
   - On success: `File.Move(tempPath, outputPath, overwrite: true)`, return `ExportAdapterResult { Success = true, OutputPaths = new[] { outputPath } }`
   - On exception: delete temp file if it exists, re-throw (let caller handle)

4. **Status mapping method** (`MapStatusToXccdf`):
   - ControlResult.Status is a string. Normalize by trimming, lowercasing, and stripping underscores/hyphens/spaces (mirror ScapResultAdapter.MapScapStatus normalization logic).
   - Map to canonical XCCDF values that ScapResultAdapter.MapScapStatus() will parse back correctly.

5. **Severity-to-weight mapping** (`MapSeverityToWeight`):
   - Reverse of ScapResultAdapter.MapWeightToSeverity: `"high" -> "10.0"`, `"medium" -> "5.0"`, `"low" -> "1.0"`. Return null for unknown/null (omit weight attribute).

Create `tests/STIGForge.UnitTests/Export/XccdfExportAdapterTests.cs`:

- **FormatName_Is_XCCDF**: Assert FormatName == "XCCDF"
- **SupportedExtensions_Contains_Xml**: Assert SupportedExtensions contains ".xml"
- **ExportAsync_ProducesValidXccdfXml**: Create adapter, call ExportAsync with 2 ControlResult items (one Pass/high, one Fail/medium), verify output file exists, parse as XDocument, assert root is `Benchmark` in XccdfNs, assert `TestResult` descendant has 2 `rule-result` children
- **ExportAsync_RoundTrip_ScapResultAdapterCanParse**: Export 3 ControlResult items, then use `ScapResultAdapter.CanHandle()` to verify it returns true, then use `ScapResultAdapter.ParseResults()` and assert result count == 3
- **ExportAsync_AllElementsHaveXccdfNamespace**: Export results, parse XML, walk all descendant elements with `doc.Descendants()`, assert every element's `Name.Namespace == XccdfNs`
- **ExportAsync_PartialFileDeletedOnError**: Pass an invalid OutputDirectory (e.g., path with illegal characters or a read-only path) to trigger a write failure, assert no `.tmp` file remains
- **ExportAsync_EmptyResults_ProducesValidXml**: Export with empty results list, verify XML is valid with TestResult but zero rule-result children, verify ScapResultAdapter.CanHandle() still returns true
- **ExportAsync_NullFields_HandledGracefully**: Export a ControlResult with all nullable fields null, verify no exception and valid XML output

Use `[Fact]` attribute, xUnit assertions. Create temp directories with `Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString())` and clean up in Dispose.
  </action>
  <verify>
Run `dotnet test tests/STIGForge.UnitTests --filter "FullyQualifiedName~XccdfExportAdapterTests" --no-restore` — all tests pass.
Run `dotnet build src/STIGForge.Export` — builds without errors or warnings.
  </verify>
  <done>
XccdfExportAdapter implements IExportAdapter, generates valid XCCDF 1.2 XML with namespace on every element, passes ScapResultAdapter round-trip validation, and deletes partial output on failure. All unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire export-xccdf CLI command</name>
  <files>
    src/STIGForge.Cli/Commands/ExportCommands.cs
  </files>
  <action>
Add `RegisterExportXccdf` to `ExportCommands.cs`, following the exact pattern of `RegisterExportCkl`:

1. **Register method call:** Add `RegisterExportXccdf(rootCmd, buildHost);` to the `Register` method alongside existing `RegisterExportPoam` and `RegisterExportCkl` calls.

2. **RegisterExportXccdf method:**
   ```
   var cmd = new Command("export-xccdf", "Export verify results as XCCDF 1.2 XML for Tenable, ACAS, STIG Viewer interop");
   ```
   Options:
   - `--bundle` (required): Bundle root path
   - `--output`: Output directory override (default empty)
   - `--file-name`: Output file name stem (default empty, adapter uses "stigforge_xccdf_results")

3. **Handler logic:**
   - Build host, start it
   - Log: `"export-xccdf started: bundle={Bundle}"`
   - Load verify results from bundle using the same pattern as EmassExporter/CklExporter:
     ```csharp
     var verifyRoot = Path.Combine(bundle, "Verify");
     var results = new List<ControlResult>();
     if (Directory.Exists(verifyRoot))
     {
         var reports = Directory.GetFiles(verifyRoot, "consolidated-results.json", SearchOption.AllDirectories);
         foreach (var reportPath in reports)
         {
             var report = VerifyReportReader.LoadFromJson(reportPath);
             results.AddRange(report.Results);
         }
     }
     ```
   - Create `XccdfExportAdapter` and call `ExportAsync`:
     ```csharp
     var adapter = new XccdfExportAdapter();
     var exportResult = await adapter.ExportAsync(new ExportAdapterRequest
     {
         BundleRoot = bundle,
         Results = results,
         OutputDirectory = string.IsNullOrWhiteSpace(output) ? Path.Combine(bundle, "Export") : output,
         FileNameStem = string.IsNullOrWhiteSpace(fileName) ? null : fileName
     }, CancellationToken.None);
     ```
   - Print results: file path, result count
   - Log completion
   - Stop host

4. Add required `using` statements: `using STIGForge.Verify;` (for VerifyReportReader), `using STIGForge.Export;` (likely already present).
  </action>
  <verify>
Run `dotnet build src/STIGForge.Cli` — builds without errors.
Run `dotnet run --project src/STIGForge.Cli -- export-xccdf --help` — shows help with --bundle, --output, --file-name options.
Run full test suite: `dotnet test --no-restore` — all existing tests still pass (no regressions).
  </verify>
  <done>
The `export-xccdf` CLI command is registered, accepts --bundle/--output/--file-name options, loads verify results from consolidated-results.json, calls XccdfExportAdapter.ExportAsync, and prints the output path. All existing tests pass with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `dotnet test --no-restore` — full test suite passes (existing + new XccdfExportAdapter tests)
2. `dotnet build` — solution builds without errors or warnings
3. Round-trip validation: XccdfExportAdapter output is parseable by ScapResultAdapter with matching result count
4. Namespace check: every element in exported XML has XCCDF 1.2 namespace
5. Fail-closed: no partial .tmp files left on adapter failure
</verification>

<success_criteria>
- XccdfExportAdapter.cs exists and implements IExportAdapter (FormatName="XCCDF", SupportedExtensions=[".xml"])
- Exported XML has Benchmark root with TestResult child, all elements in http://checklists.nist.gov/xccdf/1.2 namespace
- ScapResultAdapter.CanHandle() returns true for exported files
- ScapResultAdapter.ParseResults() returns same count as input ControlResult list
- Partial output file deleted on adapter exception
- export-xccdf CLI command available with --bundle, --output, --file-name options
- All unit tests pass including round-trip, namespace, empty-results, and null-field tests
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/16-xccdf-result-export/16-01-SUMMARY.md`
</output>
