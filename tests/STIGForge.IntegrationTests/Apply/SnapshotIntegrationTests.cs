using System.Diagnostics;
using System.Text;
using FluentAssertions;
using Microsoft.Extensions.Logging;
using Xunit;
using STIGForge.Apply.Snapshot;

namespace STIGForge.IntegrationTests.Apply;

[Trait("Category", "Integration")]
[Collection("Integration")]
public sealed class SnapshotIntegrationTests
{
    [Fact(Skip = "Requires administrator privileges")]
    public async Task CreateSnapshot_ProducesValidFiles()
    {
        // Arrange
        var logger = LoggerFactory.Create(builder => builder.AddConsole()).CreateLogger<SnapshotService>();
        var service = new SnapshotService(logger);
        var snapshotsDir = Path.Combine(Path.GetTempPath(), "test_snapshot_" + Guid.NewGuid());
        Directory.CreateDirectory(snapshotsDir);
        
        try
        {
            // Act
            var result = await service.CreateSnapshot(snapshotsDir, CancellationToken.None);
            
            // Assert
            result.Should().NotBeNull();
            result.SnapshotId.Should().NotBeNullOrEmpty();
            result.SecurityPolicyPath.Should().NotBeNullOrEmpty();
            result.AuditPolicyPath.Should().NotBeNullOrEmpty();
            
            File.Exists(result.SecurityPolicyPath).Should().BeTrue("Security policy .inf file should exist");
            File.Exists(result.AuditPolicyPath).Should().BeTrue("Audit policy .csv file should exist");
            
            // Verify file has content
            var securityPolicyContent = await File.ReadAllTextAsync(result.SecurityPolicyPath);
            securityPolicyContent.Should().NotBeNullOrEmpty();
            securityPolicyContent.Should().Contain("[Version]", "Security policy should contain version header");
            
            var auditPolicyContent = await File.ReadAllTextAsync(result.AuditPolicyPath);
            auditPolicyContent.Should().NotBeNullOrEmpty("Audit policy should have content");
        }
        finally
        {
            // Cleanup
            if (Directory.Exists(snapshotsDir))
                Directory.Delete(snapshotsDir, true);
        }
    }

    [Fact]
    public async Task RollbackScript_IsExecutable()
    {
        // Arrange
        var logger = LoggerFactory.Create(builder => builder.AddConsole()).CreateLogger<RollbackScriptGenerator>();
        var generator = new RollbackScriptGenerator(logger);
        var snapshot = new SnapshotResult
        {
            SnapshotId = "test_snapshot_" + Guid.NewGuid(),
            CreatedAt = DateTimeOffset.Now,
            SecurityPolicyPath = "C:\\temp\\security_policy.inf",
            AuditPolicyPath = "C:\\temp\\audit_policy.csv",
            LgpoStatePath = "C:\\temp\\lgpo_state",
            RollbackScriptPath = "C:\\temp\\rollback.ps1"
        };
        
        // Act
        var scriptPath = generator.GenerateScript(snapshot);
        
        // Assert
        scriptPath.Should().NotBeNullOrEmpty();
        File.Exists(scriptPath).Should().BeTrue("Rollback script should be created");
        
        var scriptContent = await File.ReadAllTextAsync(scriptPath);
        scriptContent.Should().Contain("secedit", "Script should contain secedit command");
        scriptContent.Should().Contain("auditpol", "Script should contain auditpol command");
        scriptContent.Should().Contain("LGPO", "Script should contain LGPO restore");
        scriptContent.Should().Contain("Rollback script generated by STIGForge", "Script should have header");
        scriptContent.Should().Contain("$ErrorActionPreference = 'Stop'", "Script should set error action");
        scriptContent.Should().Contain("Reboot recommended", "Script should recommend reboot");
    }

    [Fact(Skip = "Requires administrator privileges")]
    public async Task RestoreSnapshot_ExecutesWithoutError()
    {
        // Arrange
        var logger = LoggerFactory.Create(builder => builder.AddConsole()).CreateLogger<SnapshotService>();
        var service = new SnapshotService(logger);
        var snapshotsDir = Path.Combine(Path.GetTempPath(), "test_snapshot_" + Guid.NewGuid());
        Directory.CreateDirectory(snapshotsDir);
        
        var snapshot = await service.CreateSnapshot(snapshotsDir, CancellationToken.None);
        
        try
        {
            // Act
            await service.RestoreSnapshot(snapshot, CancellationToken.None);
            
            // Assert - if we get here without exception, restore succeeded
        }
        finally
        {
            // Cleanup
            if (Directory.Exists(snapshotsDir))
                Directory.Delete(snapshotsDir, true);
        }
    }

    [Fact]
    public async Task SnapshotFailure_PreventsApply()
    {
        // Arrange
        var logger = LoggerFactory.Create(builder => builder.AddConsole()).CreateLogger<SnapshotService>();
        var service = new SnapshotService(logger);
        var snapshotsDir = Path.Combine(Path.GetTempPath(), "test_snapshot_" + Guid.NewGuid());
        
        // Create an invalid directory path to trigger failure
        var invalidDir = Path.Combine(snapshotsDir, "invalid", "path", "that", "does", "not", "exist");
        
        try
        {
            // Act & Assert
            await Assert.ThrowsAsync<SnapshotException>(async () =>
            {
                await service.CreateSnapshot(invalidDir, CancellationToken.None);
            });
        }
        finally
        {
            // Cleanup
            if (Directory.Exists(snapshotsDir))
                Directory.Delete(snapshotsDir, true);
        }
    }
}
